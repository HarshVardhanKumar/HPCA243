// Code submitted for the Third Data Prefetching Championship
//
// Author: Alberto Ros, University of Murcia
//
// Paper #13: Berti: A Per-Page Best-Request-Time Delta Prefetcher

#include "cache.h"
#include <bits/stdc++.h>
#define LOOKAHEAD_ON
#define FILTER_ON
#define GHR_ON
#define SPP_SANITY_CHECK

#define SPP_DEBUG_PRINT
#ifdef SPP_DEBUG_PRINT
#define SPP_DP(x) x
#else
#define SPP_DP(x)
#endif

#define SPP_PERC_WGHT
#ifdef SPP_PERC_WGHT
#define SPP_PW(x) x
#else
#define SPP_PW(x)
#endif

// Signature table parameters
#define ST_SET 1
#define ST_WAY 256
#define ST_TAG_BIT 16
#define ST_TAG_MASK ((1 << ST_TAG_BIT) - 1)
#define SIG_SHIFT 3
#define SIG_BIT 12
#define SIG_MASK ((1 << SIG_BIT) - 1)
#define SIG_DELTA_BIT 7

// Pattern table parameters
#define PT_SET 2048
#define PT_WAY 4
#define C_SIG_BIT 4
#define C_DELTA_BIT 4
#define C_SIG_MAX ((1 << C_SIG_BIT) - 1)
#define C_DELTA_MAX ((1 << C_DELTA_BIT) - 1)

// Prefetch filter parameters
#define QUOTIENT_BIT  10
#define REMAINDER_BIT 6  // maybe 6 bits to perform tag matching
#define HASH_BIT (QUOTIENT_BIT + REMAINDER_BIT + 1)	// what is this for?  VALUE IS 17
#define FILTER_SET (1 << QUOTIENT_BIT)			// 2^10 enteries

#define QUOTIENT_BIT_REJ  10				// for reject tables
#define REMAINDER_BIT_REJ 8
#define HASH_BIT_REJ (QUOTIENT_BIT_REJ + REMAINDER_BIT_REJ + 1)  // HASH_BIT_REJ = 19
#define FILTER_SET_REJ (1 << QUOTIENT_BIT_REJ)

// Global register parameters
#define GLOBAL_COUNTER_BIT 10
#define GLOBAL_COUNTER_MAX ((1 << GLOBAL_COUNTER_BIT) - 1)
#define MAX_GHR_ENTRY 8
#define PAGES_TRACKED 6

// Perceptron paramaters
#define PERC_ENTRIES 4096 //Upto 12-bit addressing in hashed perceptron
#define PERC_FEATURES 9 //Keep increasing based on new features
#define PERC_COUNTER_MAX 15 //-16 to +15: 5 bits counter
#define PERC_THRESHOLD_HI  -5	// THETA_HI
#define PERC_THRESHOLD_LO  -15	// THETA_LOW
#define POS_UPDT_THRESHOLD  90	//POSITIVE UPDATE THRESHOLD
#define NEG_UPDT_THRESHOLD -80	// NEGATIVE UPDATE THRESHOLD

using namespace std;

enum FILTER_REQUEST {L2C_PREFETCH, LLC_PREFETCH, L2C_DEMAND, L2C_EVICT, PERC_REJECT}; // Request type for prefetch filter
enum FILTER_REQUEST_SPP {SPP_L2C_PREFETCH, SPP_LLC_PREFETCH, L2C_DEMAND, L2C_EVICT, SPP_PERC_REJECT};

uint64_t get_hash(uint64_t key);

class PERCEPTRON_BERTI {
public:
  // Perc Weights
  int32_t perc_weights[PERC_ENTRIES][PERC_FEATURES];

  // CONST depths for different features. Used only for getting the indices
  int32_t PERC_DEPTH[PERC_FEATURES];	// the iteration counter on which the spp manages to predict prefetch entries in the lookaheadd manner is called it's depth

  PERCEPTRON_BERTI() {
    cout << "\nInitialize PERCEPTRON" << endl;
    cout << "PERC_ENTRIES: " << PERC_ENTRIES << endl;
    cout << "PERC_FEATURES: " << PERC_FEATURES << endl;

    PERC_DEPTH[0] = 2048;   //base_addr;
    PERC_DEPTH[1] = 4096;   //cache_line;
    PERC_DEPTH[2] = 4096;  	//page_addr;
    PERC_DEPTH[3] = 4096;   //confidence ^ page_addr;
    PERC_DEPTH[4] = 1024;	//curr_sig ^ sig_delta;
    PERC_DEPTH[5] = 4096; 	//ip_1 ^ ip_2 ^ ip_3;
    PERC_DEPTH[6] = 1024; 	//ip ^ depth;
    PERC_DEPTH[7] = 2048;   //ip ^ sig_delta;
    PERC_DEPTH[8] = 128;   	//confidence;

    for (int i = 0; i < PERC_ENTRIES; i++) {
      for (int j = 0;j < PERC_FEATURES; j++) {
        perc_weights[i][j] = 0;
      }
    }
  }

  void perc_update(int first_offset, uint64_t base_addr, int current_berti, uint64_t ip, uint64_t ip_1, uint64_t ip_2, uint64_t ip_3, int32_t cur_delta, uint32_t confidence, uint32_t depth, bool direction, int32_t perc_sum);
  int32_t	perc_predict(int first_offset, uint64_t check_addr, int current_berti, uint64_t ip, uint64_t ip_1, uint64_t ip_2, uint64_t ip_3, int32_t cur_delta, uint32_t confidence, uint32_t depth);
};

class GLOBAL_REGISTER {
public:
  // Global counters to calculate global prefetching accuracy
  uint64_t pf_useful,
  pf_issued,
  global_accuracy; // Alpha value in Section III. Equation 3

  // Global History Register (GHR) entries
  uint8_t  valid[MAX_GHR_ENTRY];
  uint32_t sig[MAX_GHR_ENTRY],
  confidence[MAX_GHR_ENTRY],
  offset[MAX_GHR_ENTRY];
  int deltaa[MAX_GHR_ENTRY];

  uint64_t ip[32],addr[32];

  uint64_t page_tracker[PAGES_TRACKED];

  GLOBAL_REGISTER() {
    pf_useful = 0;
    pf_issued = 0;
    global_accuracy = 0;
    for (int i =0; i<32; i++) {
      ip[i] = 0;
      addr[i] = 0;
    }

    for (uint32_t i = 0; i < MAX_GHR_ENTRY; i++) {
      valid[i] = 0;
      sig[i] = 0;
      confidence[i] = 0;
      offset[i] = 0;
      deltaa[i] = 0;
    }
  }

  void update_entry(uint32_t pf_sig, uint32_t pf_confidence, uint32_t pf_offset, int pf_delta);
  uint32_t check_entry(uint32_t page_offset);
};

class PREFETCH_FILTER_BERTI {

public:
  uint64_t remainder_tag[FILTER_SET],		// FILTER_SET = 2^10; used for tag matching?

  pc[FILTER_SET],	// feature from spp
  pc_1[FILTER_SET],	// feature from spp	last pc before the inst that triggered the current prefetch
  pc_2[FILTER_SET],	// feature from spp	second last pc before pc
  pc_3[FILTER_SET],	// feature from spp
  address[FILTER_SET];

  bool valid[FILTER_SET],  // Consider this as "prefetched"
  useful[FILTER_SET]; // Consider this as "used"

  int32_t	deltaa[FILTER_SET],
  first_offsett[FILTER_SET],
  current_bertii[FILTER_SET],	// delta how to calculate? only 1024 addresses?
  perc_sum[FILTER_SET];	//perceptron sum for each entry in the feature table?, signed.

  uint32_t confidence[FILTER_SET],
  la_depth[FILTER_SET];	// lookahead depth; exported from spp

  uint64_t remainder_tag_reject[FILTER_SET_REJ],
  pc_reject[FILTER_SET_REJ],
  pc_1_reject[FILTER_SET_REJ],
  pc_2_reject[FILTER_SET_REJ],
  pc_3_reject[FILTER_SET_REJ],
  address_reject[FILTER_SET_REJ];

  bool 	 valid_reject[FILTER_SET_REJ]; // Entries which the perceptron rejected
  int32_t	 delta_reject[FILTER_SET_REJ],
  first_offset_reject[FILTER_SET_REJ],
  current_berti_reject[FILTER_SET_REJ],
  perc_sum_reject[FILTER_SET_REJ];

  uint32_t
  confidence_reject[FILTER_SET_REJ],
  la_depth_reject[FILTER_SET_REJ];

  PREFETCH_FILTER_BERTI() {
    cout << endl << "Initialize PREFETCH FILTER" << endl;
    cout << "FILTER_SET: " << FILTER_SET << endl;
    // initialization to 0
    for (uint32_t set = 0; set < FILTER_SET; set++) {
      remainder_tag[set] = 0;
      valid[set] = 0;
      useful[set] = 0;
    }
    // initialization to 0
    for (uint32_t set = 0; set < FILTER_SET_REJ; set++) {
      valid_reject[set] = 0;
      remainder_tag_reject[set] = 0;
    }
  }

  bool check(uint64_t check_addr,  int first_offset, uint64_t base_addr, int current_berti, uint64_t ip, FILTER_REQUEST filter_request, int cur_delta, uint32_t conf, int32_t sum, uint32_t depth);
};

class SIGNATURE_TABLE {
public:
  bool     valid[ST_SET][ST_WAY];
  uint32_t tag[ST_SET][ST_WAY],
  last_offset[ST_SET][ST_WAY],
  sig[ST_SET][ST_WAY],
  lru[ST_SET][ST_WAY];

  SIGNATURE_TABLE() {
    cout << "Initialize SIGNATURE TABLE" << endl;
    cout << "ST_SET: " << ST_SET << endl;
    cout << "ST_WAY: " << ST_WAY << endl;
    cout << "ST_TAG_BIT: " << ST_TAG_BIT << endl;
    cout << "ST_TAG_MASK: " << hex << ST_TAG_MASK << dec << endl;

    for (uint32_t set = 0; set < ST_SET; set++)
    for (uint32_t way = 0; way < ST_WAY; way++) {
      valid[set][way] = 0;
      tag[set][way] = 0;
      last_offset[set][way] = 0;
      sig[set][way] = 0;
      lru[set][way] = way;
    }
  };

  void read_and_update_sig(uint64_t page, uint32_t page_offset, uint32_t &last_sig, uint32_t &curr_sig, int32_t &delta);
};

class PATTERN_TABLE {
public:
  int      delta[PT_SET][PT_WAY];
  uint32_t c_delta[PT_SET][PT_WAY],
  c_sig[PT_SET];

  PATTERN_TABLE() {
    cout << endl << "Initialize PATTERN TABLE" << endl;
    cout << "PT_SET: " << PT_SET << endl;
    cout << "PT_WAY: " << PT_WAY << endl;
    cout << "SIG_DELTA_BIT: " << SIG_DELTA_BIT << endl;
    cout << "C_SIG_BIT: " << C_SIG_BIT << endl;
    cout << "C_DELTA_BIT: " << C_DELTA_BIT << endl;

    for (uint32_t set = 0; set < PT_SET; set++) {
      for (uint32_t way = 0; way < PT_WAY; way++) {
        delta[set][way] = 0;
        c_delta[set][way] = 0;
      }
      c_sig[set] = 0;
    }
  }

  void update_pattern(uint32_t last_sig, int curr_delta),
  read_pattern(uint32_t curr_sig, int *prefetch_delta, uint32_t *confidence_q, int32_t *perc_sum_q, uint32_t &lookahead_way, uint32_t &lookahead_conf, uint32_t &pf_q_tail, uint32_t &depth, uint64_t addr, uint64_t base_addr, uint64_t train_addr, uint64_t curr_ip, int32_t train_delta, uint32_t last_sig, uint32_t pq_occupancy, uint32_t pq_SIZE, uint32_t mshr_occupancy, uint32_t mshr_SIZE);
};

class PREFETCH_FILTER {
  //set of features used by perceptron
  // physical address: lower bits of the physical address of the demand access that triggers the prefetch. Corresponds to the stream of accesses 					that spp and ppf have seen before.
  // CACHE_LINE, PAGE_ADDRESS: derived by shifting the base address(that triggered the prefetch) by the size of cache block , or size of page
  // PC^DEPTH: pc-for the instn that triggered the prefetch. Depth - iteration count of the lookahead stages.
  // PC1^(PC2>>1)^(PC3>>2):
  // PC ^ DELTA: tell if a given PC favours particular values of delta
  // CONFIDENCE: on the scale of 0-100 used to throttle lookahead depth in original spp. Correlates with the correctness of proposed prefetch.
  // PAGE_ADDRESS ^ CONFIDENCE: the tendency of each page to be prefetch friendly or prefetch averse. Helps to resolve a page into different 						entries in the basis of confidence for prefetching.
  // CURRENT_SIGNATURE^DELTA
public:
  uint64_t remainder_tag[FILTER_SET],		// FILTER_SET = 2^10; used for tag matching?

  pc[FILTER_SET],	// feature from spp
  pc_1[FILTER_SET],	// feature from spp	last pc before the inst that triggered the current prefetch
  pc_2[FILTER_SET],	// feature from spp	second last pc before pc
  pc_3[FILTER_SET],	// feature from spp
  address[FILTER_SET];	// spp

  bool valid[FILTER_SET],  // Consider this as "prefetched"
  useful[FILTER_SET]; // Consider this as "used"

  int32_t	delta[FILTER_SET],	// delta how to calculate? only 1024 addresses?
  perc_sum[FILTER_SET];	//perceptron sum for each entry in the feature table?, signed.
  uint32_t last_signature[FILTER_SET],		// feature from sp
  confidence[FILTER_SET],	// feature from spp
  cur_signature[FILTER_SET],	// feature from spp
  la_depth[FILTER_SET];	// lookahead depth; exported from spp

  uint64_t remainder_tag_reject[FILTER_SET_REJ],
  pc_reject[FILTER_SET_REJ],
  pc_1_reject[FILTER_SET_REJ],
  pc_2_reject[FILTER_SET_REJ],
  pc_3_reject[FILTER_SET_REJ],
  address_reject[FILTER_SET_REJ];
  bool 	 valid_reject[FILTER_SET_REJ]; // Entries which the perceptron rejected
  int32_t	 delta_reject[FILTER_SET_REJ],
  perc_sum_reject[FILTER_SET_REJ];
  uint32_t last_signature_reject[FILTER_SET_REJ],
  confidence_reject[FILTER_SET_REJ],
  cur_signature_reject[FILTER_SET_REJ],
  la_depth_reject[FILTER_SET_REJ];

  PREFETCH_FILTER() {
    cout << endl << "Initialize PREFETCH FILTER" << endl;
    cout << "FILTER_SET: " << FILTER_SET << endl;
    // initialization to 0
    for (uint32_t set = 0; set < FILTER_SET; set++) {
      remainder_tag[set] = 0;
      valid[set] = 0;
      useful[set] = 0;
    }
    // initialization to 0
    for (uint32_t set = 0; set < FILTER_SET_REJ; set++) {
      valid_reject[set] = 0;
      remainder_tag_reject[set] = 0;
    }
  }

  bool check(uint64_t pf_addr, uint64_t base_addr, uint64_t ip, FILTER_REQUEST_SPP filter_request, int32_t cur_delta, uint32_t last_sign, uint32_t cur_sign, uint32_t confidence, int32_t sum, uint32_t depth);
};

class PERCEPTRON {
public:
  // Perc Weights
  int32_t perc_weights[PERC_ENTRIES][PERC_FEATURES];

  // CONST depths for different features. Used only for getting the indices
  int32_t PERC_DEPTH[PERC_FEATURES];	// the iteration counter on which the spp manages to predict prefetch entries in the lookaheadd manner is called it's depth

  PERCEPTRON() {
    cout << "\nInitialize PERCEPTRON" << endl;
    cout << "PERC_ENTRIES: " << PERC_ENTRIES << endl;
    cout << "PERC_FEATURES: " << PERC_FEATURES << endl;

    PERC_DEPTH[0] = 2048;   //base_addr;
    PERC_DEPTH[1] = 4096;   //cache_line;
    PERC_DEPTH[2] = 4096;  	//page_addr;
    PERC_DEPTH[3] = 4096;   //confidence ^ page_addr;
    PERC_DEPTH[4] = 1024;	//curr_sig ^ sig_delta;
    PERC_DEPTH[5] = 4096; 	//ip_1 ^ ip_2 ^ ip_3;
    PERC_DEPTH[6] = 1024; 	//ip ^ depth;
    PERC_DEPTH[7] = 2048;   //ip ^ sig_delta;
    PERC_DEPTH[8] = 128;   	//confidence;

    for (int i = 0; i < PERC_ENTRIES; i++) {
      for (int j = 0;j < PERC_FEATURES; j++) {
        perc_weights[i][j] = 0;
      }
    }
  }

  void	 perc_update(uint64_t check_addr, uint64_t ip, uint64_t ip_1, uint64_t ip_2, uint64_t ip_3, int32_t cur_delta, uint32_t last_sig, uint32_t curr_sig, uint32_t confidence, uint32_t depth, bool direction, int32_t perc_sum);
  int32_t	perc_predict(uint64_t check_addr, uint64_t ip, uint64_t ip_1, uint64_t ip_2, uint64_t ip_3, int32_t cur_delta, uint32_t last_sig, uint32_t curr_sig, uint32_t confidence, uint32_t depth);
};

PREFETCH_FILTER_BERTI B_FILTER;
SIGNATURE_TABLE ST;
PATTERN_TABLE PT;
PREFETCH_FILTER FILTER;
GLOBAL_REGISTER GHR;
PERCEPTRON_BERTI PERCB;
PERCEPTRON PERC;

uint64_t get_hash(uint64_t key){
  // Robert Jenkins' 32 bit mix function
  key += (key << 12);
  key ^= (key >> 22);
  key += (key << 4);
  key ^= (key >> 9);
  key += (key << 10);
  key ^= (key >> 2);
  key += (key << 7);
  key ^= (key >> 12);

  // Knuth's multiplicative method
  key = (key >> 3) * 2654435761;

  return key;
}

void get_perc_index_berti(int first_offset, uint64_t base_addr, int current_berti, uint64_t ip, uint64_t ip_1, uint64_t ip_2, uint64_t ip_3, int32_t cur_delta, uint32_t confidence, uint32_t depth, uint64_t perc_set[PERC_FEATURES]){
  // Returns the indexes for the perceptron tables
  uint64_t cache_line = base_addr >> LOG2_BLOCK_SIZE,
  page_addr  = base_addr >> LOG2_PAGE_SIZE;

  //int sig_delta = (cur_delta < 0) ? (((-1) * cur_delta) + (1 << (SIG_DELTA_BIT - 1))) : cur_delta;
  uint64_t  pre_hash[PERC_FEATURES];

  // calculate no. of delta values
  int n_delta = 0;
  for (int i = 31; i>=0; i--) {
    if (n_delta == GHR.addr[i]-GHR.addr[i-1])
      n_delta ++ ;
  }
  pre_hash[0] = base_addr;
  pre_hash[1] = cache_line;
  pre_hash[2] = page_addr;
  pre_hash[3] = confidence ^ page_addr;
  pre_hash[4] = (ip&first_offset);
  pre_hash[5] = ip_1 ^ (ip_2>>1) ^ (ip_3>>2);
  pre_hash[6] = confidence^ ip ^ current_berti;
  pre_hash[7] = n_delta;
  pre_hash[8] = confidence;

  for (int i = 0; i < PERC_FEATURES; i++) {
    perc_set[i] = (pre_hash[i]) % PERCB.PERC_DEPTH[i]; // Variable depths
  }
}

int32_t	PERCEPTRON_BERTI::perc_predict( int first_offset, uint64_t base_addr,int current_berti, uint64_t ip, uint64_t ip_1, uint64_t ip_2, uint64_t ip_3, int32_t cur_delta, uint32_t confidence, uint32_t depth){
  uint64_t perc_set[PERC_FEATURES];
  // Get the indexes in perc_set[]
  get_perc_index_berti(first_offset,base_addr, current_berti,ip, ip_1, ip_2, ip_3, cur_delta, confidence, depth, perc_set);

  int32_t sum = 0;
  for (int i = 0; i < PERC_FEATURES; i++) {
    sum += perc_weights[perc_set[i]][i];
    // Calculate Sum
  }
  // Return the sum
  return sum;
}

void 	PERCEPTRON_BERTI::perc_update( int32_t first_offset, uint64_t base_addr, int32_t current_berti, uint64_t ip, uint64_t ip_1, uint64_t ip_2, uint64_t ip_3, int32_t cur_delta, uint32_t confidence, uint32_t depth, bool direction, int32_t perc_sum){
  uint64_t perc_set[PERC_FEATURES];
  // Get the perceptron indexes
  get_perc_index_berti(first_offset,base_addr,current_berti, ip, ip_1, ip_2, ip_3, cur_delta, confidence, depth, perc_set);

  int32_t sum = 0;
  // Restore the sum that led to the prediction
  sum = perc_sum;

  if (!direction) { // direction = 1 means the sum was in the correct direction, 0 means it was in the wrong direction // Prediction wrong
    for (int i = 0; i < PERC_FEATURES; i++) {
      if (sum >= PERC_THRESHOLD_HI) {
        // Prediction was to prefectch -- so decrement counters
        if (perc_weights[perc_set[i]][i] > -1*(PERC_COUNTER_MAX+1) )
        perc_weights[perc_set[i]][i]--;
      }
      if (sum < PERC_THRESHOLD_HI) {
        // Prediction was to not prefetch -- so increment counters
        if (perc_weights[perc_set[i]][i] < PERC_COUNTER_MAX)
        perc_weights[perc_set[i]][i]++;
      }
    }
  }

  if (direction && sum > NEG_UPDT_THRESHOLD && sum < POS_UPDT_THRESHOLD) {
    // Prediction correct but sum not 'saturated' enough
    for (int i = 0; i < PERC_FEATURES; i++) {
      if (sum >= PERC_THRESHOLD_HI) {
        // Prediction was to prefetch -- so increment counters
        if (perc_weights[perc_set[i]][i] < PERC_COUNTER_MAX)
        perc_weights[perc_set[i]][i]++;
      }
      if (sum < PERC_THRESHOLD_HI) {
        // Prediction was to not prefetch -- so decrement counters
        if (perc_weights[perc_set[i]][i] > -1*(PERC_COUNTER_MAX+1) )
        perc_weights[perc_set[i]][i]--;
      }
    }
  }
}

bool PREFETCH_FILTER_BERTI::check(uint64_t check_addr,  int first_offset, uint64_t base_addr, int current_berti, /*uint6*/ uint64_t ip, FILTER_REQUEST filter_request, int cur_delta, uint32_t conf, int32_t sum, uint32_t depth){
  uint64_t cache_line = check_addr >> LOG2_BLOCK_SIZE, // cache line address. But what size it is?
  hash = get_hash(cache_line); // size of hash?

  //MAIN FILTER
  uint64_t quotient = (hash >> REMAINDER_BIT) & ((1 << QUOTIENT_BIT) - 1), // masking with 1111111111. That is, the last 10bits. used for indexing. Maximum value can be 1023
  remainder = hash % (1 << REMAINDER_BIT);	// gets the last six bits of hash

  //REJECT FILTER
  uint64_t quotient_reject = (hash >> REMAINDER_BIT_REJ) & ((1 << QUOTIENT_BIT_REJ) - 1), // masking with 10 bits of value 1.
  remainder_reject = hash % (1 << REMAINDER_BIT_REJ);	// last 8 bits of hash

  switch (filter_request) {

    case PERC_REJECT: // To see what would have been the prediction given perceptron has rejected the PF
    if ((valid[quotient] || useful[quotient]) && remainder_tag[quotient] == remainder) {
      // We want to check if the prefetch would have gone through had perc not rejected
      // So even in perc reject case, I'm checking in the accept filter for redundancy
      return false; // False return indicates "Do not prefetch"
    }
    else {
      valid_reject[quotient_reject] = 1;
      remainder_tag_reject[quotient_reject] = remainder_reject;

      // Logging perc features
      address_reject[quotient_reject] = base_addr;
      pc_reject[quotient_reject] = ip;
      pc_1_reject[quotient_reject] = GHR.ip[1];
      pc_2_reject[quotient_reject] = GHR.ip[2];
      pc_3_reject[quotient_reject] = GHR.ip[3];
      delta_reject[quotient_reject] = cur_delta;
      perc_sum_reject[quotient_reject] = sum;
      confidence_reject[quotient_reject] = conf;
      la_depth_reject[quotient_reject] = depth;
      first_offset_reject[quotient_reject] = first_offset;
      current_berti_reject[quotient_reject] = current_berti;
    }
    break;

    case L2C_PREFETCH:
    if ((valid[quotient] || useful[quotient]) && remainder_tag[quotient] == remainder) {

      return false; // False return indicates "Do not prefetch"
    }
    else {

      valid[quotient] = 1;  // Mark as prefetched
      useful[quotient] = 0; // Reset useful bit
      remainder_tag[quotient] = remainder;

      // Logging perc features
      deltaa[quotient] = cur_delta;
      pc[quotient] = ip;
      pc_1[quotient] = GHR.ip[1];
      pc_2[quotient] = GHR.ip[2];
      pc_3[quotient] = GHR.ip[3];
      confidence[quotient] = conf;
      address[quotient] = base_addr;
      perc_sum[quotient] = sum;
      la_depth[quotient] = depth;

      first_offsett[quotient] = first_offset;
      current_bertii[quotient] = current_berti;
    }
    break;

    case LLC_PREFETCH:
    if ((valid[quotient] || useful[quotient]) && remainder_tag[quotient] == remainder) {
      return false; // False return indicates "Do not prefetch"
    } else {
      // NOTE: SPP_LLC_PREFETCH has relatively low confidence
      // Therefore, it is safe to prefetch this cache line in the large LLC and save precious L2C capacity
      // If this prefetch request becomes more confident and SPP eventually issues SPP_L2C_PREFETCH,
      // we can get this cache line immediately from the LLC (not from DRAM)
      // To allow this fast prefetch from LLC, SPP does not set the valid bit for SPP_LLC_PREFETCH

    }
    break;

    case L2C_DEMAND:
    if ((remainder_tag[quotient] == remainder) && (useful[quotient] == 0)) { // the cache line corresponding to [quotient] has not been used till.
      useful[quotient] = 1; // quotient is used for indexing? author: Harsh. Initially it was unused, but now, it is used.
      if (valid[quotient]) { //  valid[FILTER_SET],  Consider this as "prefetched". So if [quotient] line was prefetched, then this time, it is getting used. but how is valid[quotient] getting updated?
      // where is valid[quotient] getting updated?
      GHR.pf_useful++; // This cache line was prefetched by SPP and actually used in the program. how?
    }

    if (valid[quotient]) {
      // Prefetch leads to a demand hit
      PERCB.perc_update(first_offsett[quotient],address[quotient],current_bertii[quotient], pc[quotient], pc_1[quotient], pc_2[quotient], pc_3[quotient], deltaa[quotient], confidence[quotient], la_depth[quotient], 1, perc_sum[quotient]);
    }
  }
  //If NOT Prefetched
  if (!(valid[quotient] && remainder_tag[quotient] == remainder)) {
    // AND If Rejected by Perc
    if (valid_reject[quotient_reject] && remainder_tag_reject[quotient_reject] == remainder_reject) {
      // Not prefetched but could have been a good idea to prefetch
      PERCB.perc_update(first_offset_reject[quotient_reject], address_reject[quotient_reject], current_berti_reject[quotient_reject], pc_reject[quotient_reject], pc_1_reject[quotient_reject], pc_2_reject[quotient_reject], pc_3_reject[quotient_reject], delta_reject[quotient_reject], confidence_reject[quotient_reject], la_depth_reject[quotient_reject], 0, perc_sum_reject[quotient_reject]);
      valid_reject[quotient_reject] = 0;
      remainder_tag_reject[quotient_reject] = 0;
    }
  }
    break;

    case L2C_EVICT:
  // Decrease global pf_useful counter when there is a useless prefetch (prefetched but not used)
  if (valid[quotient] && !useful[quotient]) {
    if (GHR.pf_useful)
    GHR.pf_useful--;
    // Prefetch leads to eviction
    PERCB.perc_update(first_offsett[quotient],address[quotient], current_bertii[quotient], pc[quotient], pc_1[quotient], pc_2[quotient], pc_3[quotient], deltaa[quotient], confidence[quotient], la_depth[quotient], 0, perc_sum[quotient]);
  }
  // Reset filter entry
  valid[quotient] = 0;
  useful[quotient] = 0;
  delta_reject[quotient_reject] = cur_delta;
  perc_sum_reject[quotient_reject] = sum;
  remainder_tag[quotient] = 0;

  // Reset reject filter too
  valid_reject[quotient_reject] = 0;
  remainder_tag_reject[quotient_reject] = 0;

    break;

  default:
  assert(0);
}

return true;
}

void SIGNATURE_TABLE::read_and_update_sig(uint64_t page, uint32_t page_offset, uint32_t &last_sig, uint32_t &curr_sig, int32_t &delta){

  uint32_t set = get_hash(page) % ST_SET,
  match = ST_WAY,
  partial_page = page & ST_TAG_MASK;
  uint8_t  ST_hit = 0;
  int      sig_delta = 0;

  SPP_DP (cout << "[ST] " << __func__ << " page: " << hex << page << " partial_page: " << partial_page << dec << endl;);

  // Case 1: Hit
  for (match = 0; match < ST_WAY; match++) {
    if (valid[set][match] && (tag[set][match] == partial_page)) {
      last_sig = sig[set][match];
      delta = page_offset - last_offset[set][match];

      if (delta) {
        // Build a new sig based on 7-bit sign magnitude representation of delta
        //sig_delta = (delta < 0) ? ((((-1) * delta) & 0x3F) + 0x40) : delta;
        sig_delta = (delta < 0) ? (((-1) * delta) + (1 << (SIG_DELTA_BIT - 1))) : delta;
        sig[set][match] = ((last_sig << SIG_SHIFT) ^ sig_delta) & SIG_MASK;
        curr_sig = sig[set][match];
        last_offset[set][match] = page_offset;

        SPP_DP (
          cout << "[ST] " << __func__ << " hit set: " << set << " way: " << match;
          cout << " valid: " << valid[set][match] << " tag: " << hex << tag[set][match];
          cout << " last_sig: " << last_sig << " curr_sig: " << curr_sig;
          cout << " delta: " << dec << delta << " last_offset: " << page_offset << endl;
        );
      } else last_sig = 0; // Hitting the same cache line, delta is zero

      ST_hit = 1;
      break;
    }
  }

  // Case 2: Invalid
  if (match == ST_WAY) {
    for (match = 0; match < ST_WAY; match++) {
      if (valid[set][match] == 0) {
        valid[set][match] = 1;
        tag[set][match] = partial_page;
        sig[set][match] = 0;
        curr_sig = sig[set][match];
        last_offset[set][match] = page_offset;

        SPP_DP (
          cout << "[ST] " << __func__ << " invalid set: " << set << " way: " << match;
          cout << " valid: " << valid[set][match] << " tag: " << hex << partial_page;
          cout << " sig: " << sig[set][match] << " last_offset: " << dec << page_offset << endl;
        );

        break;
      }
    }
  }

  // Case 3: Miss
  if (match == ST_WAY) {
    for (match = 0; match < ST_WAY; match++) {
      if (lru[set][match] == ST_WAY - 1) { // Find replacement victim
        tag[set][match] = partial_page;
        sig[set][match] = 0;
        curr_sig = sig[set][match];
        last_offset[set][match] = page_offset;

        SPP_DP (
          cout << "[ST] " << __func__ << " miss set: " << set << " way: " << match;
          cout << " valid: " << valid[set][match] << " victim tag: " << hex << tag[set][match] << " new tag: " << partial_page;
          cout << " sig: " << sig[set][match] << " last_offset: " << dec << page_offset << endl;
        );

        break;
      }
    }

    #ifdef SPP_SANITY_CHECK
    // Assertion
    if (match == ST_WAY) {
      cout << "[ST] Cannot find a replacement victim!" << endl;
      assert(0);
    }
    #endif
  }

  #ifdef GHR_ON
  if (ST_hit == 0) {
    uint32_t GHR_found = GHR.check_entry(page_offset);
    if (GHR_found < MAX_GHR_ENTRY) {
      sig_delta = (GHR.delta[GHR_found] < 0) ? (((-1) * GHR.delta[GHR_found]) + (1 << (SIG_DELTA_BIT - 1))) : GHR.delta[GHR_found];
      sig[set][match] = ((GHR.sig[GHR_found] << SIG_SHIFT) ^ sig_delta) & SIG_MASK;
      curr_sig = sig[set][match];
    }
  }
  #endif

  // Update LRU
  for (uint32_t way = 0; way < ST_WAY; way++) {
    if (lru[set][way] < lru[set][match]) {
      lru[set][way]++;

      #ifdef SPP_SANITY_CHECK
      // Assertion
      if (lru[set][way] >= ST_WAY) {
        cout << "[ST] LRU value is wrong! set: " << set << " way: " << way << " lru: " << lru[set][way] << endl;
        assert(0);
      }
      #endif
    }
  }
  lru[set][match] = 0; // Promote to the MRU position
}

void PATTERN_TABLE::update_pattern(uint32_t last_sig, int curr_delta){
  // Update (sig, delta) correlation
  uint32_t set = get_hash(last_sig) % PT_SET,
  match = 0;

  // Case 1: Hit
  for (match = 0; match < PT_WAY; match++) {
    if (delta[set][match] == curr_delta) {
      c_delta[set][match]++;
      c_sig[set]++;
      if (c_sig[set] > C_SIG_MAX) {
        for (uint32_t way = 0; way < PT_WAY; way++)
        c_delta[set][way] >>= 1;
        c_sig[set] >>= 1;
      }

      SPP_DP (
        cout << "[PT] " << __func__ << " hit sig: " << hex << last_sig << dec << " set: " << set << " way: " << match;
        cout << " delta: " << delta[set][match] << " c_delta: " << c_delta[set][match] << " c_sig: " << c_sig[set] << endl;
      );

      break;
    }
  }

  // Case 2: Miss
  if (match == PT_WAY) {
    uint32_t victim_way = PT_WAY,
    min_counter = C_SIG_MAX;

    for (match = 0; match < PT_WAY; match++) {
      if (c_delta[set][match] < min_counter) { // Select an entry with the minimum c_delta
        victim_way = match;
        min_counter = c_delta[set][match];
      }
    }

    delta[set][victim_way] = curr_delta;
    c_delta[set][victim_way] = 0;
    c_sig[set]++;
    if (c_sig[set] > C_SIG_MAX) {
      for (uint32_t way = 0; way < PT_WAY; way++)
      c_delta[set][way] >>= 1;
      c_sig[set] >>= 1;
    }

    SPP_DP (
      cout << "[PT] " << __func__ << " miss sig: " << hex << last_sig << dec << " set: " << set << " way: " << victim_way;
      cout << " delta: " << delta[set][victim_way] << " c_delta: " << c_delta[set][victim_way] << " c_sig: " << c_sig[set] << endl;
    );

    #ifdef SPP_SANITY_CHECK
    // Assertion
    if (victim_way == PT_WAY) {
      cout << "[PT] Cannot find a replacement victim!" << endl;
      assert(0);
    }
    #endif
  }
}

void PATTERN_TABLE::read_pattern(uint32_t curr_sig, int *delta_q, uint32_t *confidence_q, int32_t *perc_sum_q, uint32_t &lookahead_way, uint32_t &lookahead_conf, uint32_t &pf_q_tail, uint32_t &depth, uint64_t addr, uint64_t base_addr, uint64_t train_addr, uint64_t curr_ip, int32_t train_delta, uint32_t last_sig, uint32_t pq_occupancy, uint32_t pq_SIZE, uint32_t mshr_occupancy, uint32_t mshr_SIZE){
  // Update (sig, delta) correlation
  uint32_t set = get_hash(curr_sig) % PT_SET,
  local_conf = 0,
  pf_conf = 0,
  max_conf = 0;

  bool found_candidate = false;

  if (c_sig[set]) {
    for (uint32_t way = 0; way < PT_WAY; way++) {
      local_conf = (100 * c_delta[set][way]) / c_sig[set];
      pf_conf = depth ? (GHR.global_accuracy * c_delta[set][way] / c_sig[set] * lookahead_conf / 100) : local_conf;

      int32_t perc_sum = PERC.perc_predict(train_addr, curr_ip, GHR.ip[1], GHR.ip[2], GHR.ip[3], train_delta + delta[set][way], last_sig, curr_sig, pf_conf, depth);
      bool do_pf = (perc_sum >= PERC_THRESHOLD_LO) ? 1 : 0;
      bool fill_l2 = (perc_sum >= PERC_THRESHOLD_HI) ? 1 : 0;

      if (fill_l2 && (mshr_occupancy >= mshr_SIZE || pq_occupancy >= pq_SIZE) )
      continue;
      // Now checking against the L2C_MSHR_SIZE
      // Saving some slots in the internal PF queue by checking against do_pf
      if (pf_conf && do_pf && pf_q_tail < 100 ) {
        confidence_q[pf_q_tail] = pf_conf;
        delta_q[pf_q_tail] = delta[set][way];
        perc_sum_q[pf_q_tail] = perc_sum;
        //cout << "WAY:  "<< way << "\tPF_CONF: " << pf_conf <<  "\tIndex: " << pf_q_tail << endl;
        SPP_DP (
          cout << "[PT] State of Features: \nTrain addr: " << train_addr << "\tCurr IP: " << curr_ip << "\tIP_1: " << GHR.ip[1] << "\tIP_2: " << GHR.ip[2] << "\tIP_3: " << GHR.ip[3] << "\tDelta: " << train_delta + delta[set][way] << "\tLastSig: " << last_sig << "\tCurrSig: " << curr_sig << "\tConf: " << pf_conf << "\tDepth: " << depth << "\tSUM: "<< perc_sum  << endl;
        );
        // Lookahead path follows the most confident entry
        if (pf_conf > max_conf) {
          lookahead_way = way;
          max_conf = pf_conf;
        }
        pf_q_tail++;
        found_candidate = true;
      }
      // Recording Perc negatives
      if (pf_conf && pf_q_tail < L2C_MSHR_SIZE && (perc_sum < PERC_THRESHOLD_HI) ) {
        // Note: Using PERC_THRESHOLD_HI as the decising factor for negative case
        // Because 'trueness' of a prefetch is decisded based on the feedback from L2C
        // So even though LLC prefetches go through, they are treated as false wrt L2C in this case

        uint64_t pf_addr = (base_addr & ~(cache->BLOCK_SIZE - 1)) + (delta[set][way] << LOG2_BLOCK_SIZE);

        if ((addr & ~(cache->PAGE_SIZE - 1)) == (pf_addr & ~(cache->PAGE_SIZE - 1))) { // Prefetch request is in the same physical page
          FILTER.check(pf_addr, train_addr, curr_ip, SPP_PERC_REJECT, train_delta + delta[set][way], last_sig, curr_sig, pf_conf, perc_sum, depth);
        }
      }
    }
    lookahead_conf = max_conf;
    if (found_candidate) depth++;

    SPP_DP (cout << "global_accuracy: " << GHR.global_accuracy << " lookahead_conf: " << lookahead_conf << endl;);
  } else confidence_q[pf_q_tail] = 0;
}

bool PREFETCH_FILTER::check(uint64_t check_addr, uint64_t base_addr, uint64_t ip, FILTER_REQUEST_SPP filter_request, int cur_delta, uint32_t last_sig, uint32_t curr_sig, uint32_t conf, int32_t sum, uint32_t depth){
  uint64_t cache_line = check_addr >> LOG2_BLOCK_SIZE, // cache line address. But what size it is?
  hash = get_hash(cache_line); // size of hash?

  //MAIN FILTER
  uint64_t quotient = (hash >> REMAINDER_BIT) & ((1 << QUOTIENT_BIT) - 1), // masking with 1111111111. That is, the last 10bits. used for indexing. Maximum value can be 1023
  remainder = hash % (1 << REMAINDER_BIT);	// gets the last six bits of hash

  //REJECT FILTER
  uint64_t quotient_reject = (hash >> REMAINDER_BIT_REJ) & ((1 << QUOTIENT_BIT_REJ) - 1), // masking with 10 bits of value 1.
  remainder_reject = hash % (1 << REMAINDER_BIT_REJ);	// last 8 bits of hash

  switch (filter_request) {

    case SPP_PERC_REJECT: // To see what would have been the prediction given perceptron has rejected the PF
    if ((valid[quotient] || useful[quotient]) && remainder_tag[quotient] == remainder) {
      // We want to check if the prefetch would have gone through had perc not rejected
      // So even in perc reject case, I'm checking in the accept filter for redundancy
      SPP_DP (
        cout << "[FILTER] " << __func__ << " line is already in the filter check_addr: " << hex << check_addr << " cache_line: " << cache_line << dec;
        cout << " quotient: " << quotient << " valid: " << valid[quotient] << " useful: " << useful[quotient] << endl;
      );
      return false; // False return indicates "Do not prefetch"
    }
    else {
      valid_reject[quotient_reject] = 1;
      remainder_tag_reject[quotient_reject] = remainder_reject;

      // Logging perc features
      address_reject[quotient_reject] = base_addr;
      pc_reject[quotient_reject] = ip;
      pc_1_reject[quotient_reject] = GHR.ip[1];
      pc_2_reject[quotient_reject] = GHR.ip[2];
      pc_3_reject[quotient_reject] = GHR.ip[3];
      delta_reject[quotient_reject] = cur_delta;
      perc_sum_reject[quotient_reject] = sum;
      last_signature_reject[quotient_reject] = last_sig;
      cur_signature_reject[quotient_reject] = curr_sig;
      confidence_reject[quotient_reject] = conf;
      la_depth_reject[quotient_reject] = depth;

      SPP_DP (
        cout << "[FILTER] " << __func__ << " PF rejected by perceptron. Set valid_reject for check_addr: " << hex << check_addr << " cache_line: " << cache_line << dec;
        cout << " quotient: " << quotient << " remainder_tag: " << remainder_tag_reject[quotient_reject] << endl;
        cout << " More Recorded Metadata: Addr: " << hex << address_reject[quotient_reject] << dec << " PC: " << pc_reject[quotient_reject] << " Delta: " << delta_reject[quotient_reject] << " Last Signature: " << last_signature_reject[quotient_reject] << " Current Signature: " << cur_signature_reject[quotient_reject] << " Confidence: " << confidence_reject[quotient_reject] << endl;
      );
    }
    break;

    case SPP_L2C_PREFETCH:
    if ((valid[quotient] || useful[quotient]) && remainder_tag[quotient] == remainder) {
      SPP_DP (
        cout << "[FILTER] " << __func__ << " line is already in the filter check_addr: " << hex << check_addr << " cache_line: " << cache_line << dec;
        cout << " quotient: " << quotient << " valid: " << valid[quotient] << " useful: " << useful[quotient] << endl;
      );

      return false; // False return indicates "Do not prefetch"
    }
    else {

      valid[quotient] = 1;  // Mark as prefetched
      useful[quotient] = 0; // Reset useful bit
      remainder_tag[quotient] = remainder;

      // Logging perc features
      delta[quotient] = cur_delta;
      pc[quotient] = ip;
      pc_1[quotient] = GHR.ip[1];
      pc_2[quotient] = GHR.ip[2];
      pc_3[quotient] = GHR.ip[3];
      last_signature[quotient] = last_sig;
      cur_signature[quotient] = curr_sig;
      confidence[quotient] = conf;
      address[quotient] = base_addr;
      perc_sum[quotient] = sum;
      la_depth[quotient] = depth;

      SPP_DP (
        cout << "[FILTER] " << __func__ << " set valid for check_addr: " << hex << check_addr << " cache_line: " << cache_line << dec;
        cout << " quotient: " << quotient << " remainder_tag: " << remainder_tag[quotient] << " valid: " << valid[quotient] << " useful: " << useful[quotient] << endl;
        cout << " More Recorded Metadata: Addr:" << hex << address[quotient] << dec << " PC: " << pc[quotient] << " Delta: " << delta[quotient] << " Last Signature: " << last_signature[quotient] << " Current Signature: " << cur_signature[quotient] << " Confidence: " << confidence[quotient] << endl;
      );
    }
    break;

    case SPP_LLC_PREFETCH:
    if ((valid[quotient] || useful[quotient]) && remainder_tag[quotient] == remainder) {
      SPP_DP (
        cout << "[FILTER] " << __func__ << " line is already in the filter check_addr: " << hex << check_addr << " cache_line: " << cache_line << dec;
        cout << " quotient: " << quotient << " valid: " << valid[quotient] << " useful: " << useful[quotient] << endl;
      );

      return false; // False return indicates "Do not prefetch"
    } else {
      // NOTE: SPP_LLC_PREFETCH has relatively low confidence
      // Therefore, it is safe to prefetch this cache line in the large LLC and save precious L2C capacity
      // If this prefetch request becomes more confident and SPP eventually issues SPP_L2C_PREFETCH,
      // we can get this cache line immediately from the LLC (not from DRAM)
      // To allow this fast prefetch from LLC, SPP does not set the valid bit for SPP_LLC_PREFETCH

      SPP_DP (
        cout << "[FILTER] " << __func__ << " don't set valid for check_addr: " << hex << check_addr << " cache_line: " << cache_line << dec;
        cout << " quotient: " << quotient << " valid: " << valid[quotient] << " useful: " << useful[quotient] << endl;
      );
    }
    break;

    case L2C_DEMAND:
    if ((remainder_tag[quotient] == remainder) && (useful[quotient] == 0)) { // the cache line corresponding to [quotient] has not been used till.
      useful[quotient] = 1; // quotient is used for indexing? author: Harsh. Initially it was unused, but now, it is used.
      if (valid[quotient]) { //  valid[FILTER_SET],  Consider this as "prefetched". So if [quotient] line was prefetched, then this time, it is getting used. but how is valid[quotient] getting updated?
      // where is valid[quotient] getting updated?
      GHR.pf_useful++; // This cache line was prefetched by SPP and actually used in the program. how?
    }

    SPP_DP (
      cout << "[FILTER] " << __func__ << " set useful for check_addr: " << hex << check_addr << " cache_line: " << cache_line << dec;
      cout << " quotient: " << quotient << " valid: " << valid[quotient] << " useful: " << useful[quotient];
      cout << " GHR.pf_issued: " << GHR.pf_issued << " GHR.pf_useful: " << GHR.pf_useful << endl;
      if (valid[quotient])
      cout << " Calling Perceptron Update (INC) as L2C_DEMAND was useful" << endl;
    );

    if (valid[quotient]) {
      // Prefetch leads to a demand hit
      PERC.perc_update(address[quotient], pc[quotient], pc_1[quotient], pc_2[quotient], pc_3[quotient], delta[quotient], last_signature[quotient], cur_signature[quotient], confidence[quotient], la_depth[quotient], 1, perc_sum[quotient]);
    }
  }
  //If NOT Prefetched
  if (!(valid[quotient] && remainder_tag[quotient] == remainder)) {
    // AND If Rejected by Perc
    if (valid_reject[quotient_reject] && remainder_tag_reject[quotient_reject] == remainder_reject) {
      SPP_DP (
        cout << "[FILTER] " << __func__ << " not doing anything for check_addr: " << hex << check_addr << " cache_line: " << cache_line << dec;
        cout << " quotient: " << quotient << " valid_reject:" << valid_reject[quotient_reject];
        cout << " GHR.pf_issued: " << GHR.pf_issued << " GHR.pf_useful: " << GHR.pf_useful << endl;
        cout << " Calling Perceptron Update (DEC) as a useful L2C_DEMAND was rejected and reseting valid_reject" << endl;
      );
      // Not prefetched but could have been a good idea to prefetch
      PERC.perc_update(address_reject[quotient_reject], pc_reject[quotient_reject], pc_1_reject[quotient_reject], pc_2_reject[quotient_reject], pc_3_reject[quotient_reject], delta_reject[quotient_reject], last_signature_reject[quotient_reject], cur_signature_reject[quotient_reject], confidence_reject[quotient_reject], la_depth_reject[quotient_reject], 0, perc_sum_reject[quotient_reject]);
      valid_reject[quotient_reject] = 0;
      remainder_tag_reject[quotient_reject] = 0;
    }
  }
    break;

    case L2C_EVICT:
  // Decrease global pf_useful counter when there is a useless prefetch (prefetched but not used)
  if (valid[quotient] && !useful[quotient]) {
    if (GHR.pf_useful)
    GHR.pf_useful--;

    SPP_DP (
      cout << "[FILTER] " << __func__ << " eviction for check_addr: " << hex << check_addr << " cache_line: " << cache_line << dec;
      cout << " quotient: " << quotient << " valid: " << valid[quotient] << " useful: " << useful[quotient] << endl;
      cout << " Calling Perceptron Update (DEC) as L2C_DEMAND was not useful" << endl;
      cout << " Reseting valid_reject" << endl;
    );

    // Prefetch leads to eviction
    PERC.perc_update(address[quotient], pc[quotient], pc_1[quotient], pc_2[quotient], pc_3[quotient], delta[quotient], last_signature[quotient], cur_signature[quotient], confidence[quotient], la_depth[quotient], 0, perc_sum[quotient]);
  }
  // Reset filter entry
  valid[quotient] = 0;
  useful[quotient] = 0;delta_reject[quotient_reject] = cur_delta;
      perc_sum_reject[quotient_reject] = sum;
      last_signature_reject[quotient_reject] = last_sig;
  remainder_tag[quotient] = 0;

  // Reset reject filter too
  valid_reject[quotient_reject] = 0;
  remainder_tag_reject[quotient_reject] = 0;

    break;

  default:
  // Assertion
  cout << "[FILTER] Invalid filter request type: " << filter_request << endl;
  assert(0);
}

return true;
}

void GLOBAL_REGISTER::update_entry(uint32_t pf_sig, uint32_t pf_confidence, uint32_t pf_offset, int pf_delta){
  // NOTE: GHR implementation is slightly different from the original paper
  // Instead of matching (last_offset + delta), GHR simply stores and matches the pf_offset
  uint32_t min_conf = 100,
  victim_way = MAX_GHR_ENTRY;

  SPP_DP (
    cout << "[GHR] Crossing the page boundary pf_sig: " << hex << pf_sig << dec;
    cout << " confidence: " << pf_confidence << " pf_offset: " << pf_offset << " pf_delta: " << pf_delta << endl;
  );

  for (uint32_t i = 0; i < MAX_GHR_ENTRY; i++) {
    //if (sig[i] == pf_sig) { // TODO: Which one is better and consistent?
    // If GHR already holds the same pf_sig, update the GHR entry with the latest info
    if (valid[i] && (offset[i] == pf_offset)) {
      // If GHR already holds the same pf_offset, update the GHR entry with the latest info
      sig[i] = pf_sig;
      confidence[i] = pf_confidence;
      //offset[i] = pf_offset;
      delta[i] = pf_delta;

      SPP_DP (cout << "[GHR] Found a matching index: " << i << endl;);

      return;
    }

    // GHR replacement policy is based on the stored confidence value
    // An entry with the lowest confidence is selected as a victim
    if (confidence[i] < min_conf) {
      min_conf = confidence[i];
      victim_way = i;
    }
  }

  // Assertion
  if (victim_way >= MAX_GHR_ENTRY) {
    cout << "[GHR] Cannot find a replacement victim!" << endl;
    assert(0);
  }

  SPP_DP (
    cout << "[GHR] Replace index: " << victim_way << " pf_sig: " << hex << sig[victim_way] << dec;
    cout << " confidence: " << confidence[victim_way] << " pf_offset: " << offset[victim_way] << " pf_delta: " << delta[victim_way] << endl;
  );

  valid[victim_way] = 1;
  sig[victim_way] = pf_sig;
  confidence[victim_way] = pf_confidence;
  offset[victim_way] = pf_offset;
  delta[victim_way] = pf_delta;
}

uint32_t GLOBAL_REGISTER::check_entry(uint32_t page_offset){
  uint32_t max_conf = 0,
  max_conf_way = MAX_GHR_ENTRY;

  for (uint32_t i = 0; i < MAX_GHR_ENTRY; i++) {
    if ((offset[i] == page_offset) && (max_conf < confidence[i])) {
      max_conf = confidence[i];
      max_conf_way = i;
    }
  }

  return max_conf_way;
}

void get_perc_index(uint64_t base_addr, uint64_t ip, uint64_t ip_1, uint64_t ip_2, uint64_t ip_3, int32_t cur_delta, uint32_t last_sig, uint32_t curr_sig, uint32_t confidence, uint32_t depth, uint64_t perc_set[PERC_FEATURES]){
  // Returns the indexes for the perceptron tables
  uint64_t cache_line = base_addr >> LOG2_BLOCK_SIZE,
  page_addr  = base_addr >> LOG2_PAGE_SIZE;

  int sig_delta = (cur_delta < 0) ? (((-1) * cur_delta) + (1 << (SIG_DELTA_BIT - 1))) : cur_delta;
  uint64_t  pre_hash[PERC_FEATURES];

  pre_hash[0] = base_addr;
  pre_hash[1] = cache_line;
  pre_hash[2] = page_addr;
  pre_hash[3] = confidence ^ page_addr;
  pre_hash[4] = curr_sig ^ sig_delta;
  pre_hash[5] = ip_1 ^ (ip_2>>1) ^ (ip_3>>2);
  pre_hash[6] = ip ^ depth;
  pre_hash[7] = ip ^ sig_delta;
  pre_hash[8] = confidence;

  for (int i = 0; i < PERC_FEATURES; i++) {
    perc_set[i] = (pre_hash[i]) % PERC.PERC_DEPTH[i]; // Variable depths
    SPP_DP (
      cout << "  Perceptron Set Index#: " << i << " = " <<  perc_set[i];
    );
  }
  SPP_DP (
    cout << endl;
  );
}

int32_t	PERCEPTRON::perc_predict(uint64_t base_addr, uint64_t ip, uint64_t ip_1, uint64_t ip_2, uint64_t ip_3, int32_t cur_delta, uint32_t last_sig, uint32_t curr_sig, uint32_t confidence, uint32_t depth){
  SPP_DP (
    int sig_delta = (cur_delta < 0) ? (((-1) * cur_delta) + (1 << (SIG_DELTA_BIT - 1))) : cur_delta;
    cout << "[PERC_PRED] Current IP: " << ip << "  and  Memory Adress: " << hex << base_addr << endl;
    cout << " Last Sig: " << last_sig << " Curr Sig: " << curr_sig << dec << endl;
    cout << " Cur Delta: " << cur_delta << " Sign Delta: " << sig_delta << " Confidence: " << confidence<< endl;
    cout << " ";
  );

  uint64_t perc_set[PERC_FEATURES];
  // Get the indexes in perc_set[]
  get_perc_index(base_addr, ip, ip_1, ip_2, ip_3, cur_delta, last_sig, curr_sig, confidence, depth, perc_set);

  int32_t sum = 0;
  for (int i = 0; i < PERC_FEATURES; i++) {
    sum += perc_weights[perc_set[i]][i];
    // Calculate Sum
  }
  SPP_DP (
    cout << " Sum of perceptrons: " << sum << " Prediction made: " << ((sum >= PERC_THRESHOLD_LO) ?  ((sum >= PERC_THRESHOLD_HI) ? FILL_L2 : FILL_LLC) : 0)  << endl;
  );
  // Return the sum
  return sum;
}

void 	PERCEPTRON::perc_update(uint64_t base_addr, uint64_t ip, uint64_t ip_1, uint64_t ip_2, uint64_t ip_3, int32_t cur_delta, uint32_t last_sig, uint32_t curr_sig, uint32_t confidence, uint32_t depth, bool direction, int32_t perc_sum){
  uint64_t perc_set[PERC_FEATURES];
  get_perc_index(base_addr, ip, ip_1, ip_2, ip_3, cur_delta, last_sig, curr_sig, confidence, depth, perc_set);
  int32_t sum = 0;
  sum = perc_sum;
  if (!direction) {
    // Prediction wrong
    for (int i = 0; i < PERC_FEATURES; i++) {
      if (sum >= PERC_THRESHOLD_HI) {
        // Prediction was to prefectch -- so decrement counters
        if (perc_weights[perc_set[i]][i] > -1*(PERC_COUNTER_MAX+1) )
        perc_weights[perc_set[i]][i]--;
      }
      if (sum < PERC_THRESHOLD_HI) {
        // Prediction was to not prefetch -- so increment counters
        if (perc_weights[perc_set[i]][i] < PERC_COUNTER_MAX)
        perc_weights[perc_set[i]][i]++;
      }
    }

  }

  if (direction && sum > NEG_UPDT_THRESHOLD && sum < POS_UPDT_THRESHOLD) {
    // Prediction correct but sum not 'saturated' enough
    for (int i = 0; i < PERC_FEATURES; i++) {
      if (sum >= PERC_THRESHOLD_HI) {
        // Prediction was to prefetch -- so increment counters
        if (perc_weights[perc_set[i]][i] < PERC_COUNTER_MAX)
        perc_weights[perc_set[i]][i]++;
      }
      if (sum < PERC_THRESHOLD_HI) {
        // Prediction was to not prefetch -- so decrement counters
        if (perc_weights[perc_set[i]][i] > -1*(PERC_COUNTER_MAX+1) )
        perc_weights[perc_set[i]][i]--;
      }
    }
    SPP_DP (
      int differential = 0;
      if (sum >= PERC_THRESHOLD_HI) differential =  1;
      if (sum  < PERC_THRESHOLD_HI) differential = -1;
      cout << " Direction is: " << direction << " and sum is:" << sum;
      cout << " Overall Differential: " << differential << endl;
    );
  }
}


#define L2C_PAGE_BLOCKS_BITS (LOG2_PAGE_SIZE - LOG2_BLOCK_SIZE)
#define L2C_PAGE_BLOCKS (1 << L2C_PAGE_BLOCKS_BITS)
#define L2C_PAGE_OFFSET_MASK (L2C_PAGE_BLOCKS - 1)

#define L2C_MAX_NUM_BURST_PREFETCHES 3

#define L2C_BERTI_CTR_MED_HIGH_CONFIDENCE 2

// To access cpu in my functions
uint32_t l2c_cpu_id;

// TIME AND OVERFLOWS

#define L2C_TIME_BITS 16
#define L2C_TIME_OVERFLOW ((uint64_t)1 << L2C_TIME_BITS)
#define L2C_TIME_MASK (L2C_TIME_OVERFLOW - 1)

uint64_t l2c_get_latency(uint64_t cycle, uint64_t cycle_prev) {
  return cycle - cycle_prev;
  uint64_t cycle_masked = cycle & L2C_TIME_MASK;
  uint64_t cycle_prev_masked = cycle_prev & L2C_TIME_MASK;
  if (cycle_prev_masked > cycle_masked) {
    return (cycle_masked + L2C_TIME_OVERFLOW) - cycle_prev_masked;
  }
  return cycle_masked - cycle_prev_masked;
}

// STRIDE

int l2c_calculate_stride(uint64_t prev_offset, uint64_t current_offset) {
  int stride;
  if (current_offset > prev_offset) {
    stride = current_offset - prev_offset;
  } else {
    stride = prev_offset - current_offset;
    stride *= -1;
  }
  return stride;
}

// CURRENT PAGES TABLE

#define L2C_CURRENT_PAGES_TABLE_INDEX_BITS 6
#define L2C_CURRENT_PAGES_TABLE_ENTRIES ((1 << L2C_CURRENT_PAGES_TABLE_INDEX_BITS) - 1) // Null pointer for prev_request
#define L2C_CURRENT_PAGES_TABLE_NUM_BERTI 10
#define L2C_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS 7

typedef struct __l2c_current_page_entry {
  uint64_t page_addr; // 52 bits
  uint64_t ip; // 10 bits
  uint64_t u_vector; // 64 bits
  uint64_t first_offset; // 6 bits
  int berti[L2C_CURRENT_PAGES_TABLE_NUM_BERTI]; // 70 bits
  unsigned berti_ctr[L2C_CURRENT_PAGES_TABLE_NUM_BERTI]; // 60 bits
  uint64_t last_burst; // 6 bits
  uint64_t lru; // 6 bits
} l2c_current_page_entry;

l2c_current_page_entry l2c_current_pages_table[NUM_CPUS][L2C_CURRENT_PAGES_TABLE_ENTRIES];

void l2c_init_current_pages_table() {
  for (int i = 0; i < L2C_CURRENT_PAGES_TABLE_ENTRIES; i++) {
    l2c_current_pages_table[l2c_cpu_id][i].page_addr = 0;
    l2c_current_pages_table[l2c_cpu_id][i].ip = 0;
    l2c_current_pages_table[l2c_cpu_id][i].u_vector = 0; // not valid
    l2c_current_pages_table[l2c_cpu_id][i].last_burst = 0;
    l2c_current_pages_table[l2c_cpu_id][i].lru = i;
  }
}

uint64_t l2c_get_current_pages_entry(uint64_t page_addr) {
  for (int i = 0; i < L2C_CURRENT_PAGES_TABLE_ENTRIES; i++) {
    if (l2c_current_pages_table[l2c_cpu_id][i].page_addr == page_addr) return i;
  }
  return L2C_CURRENT_PAGES_TABLE_ENTRIES;
}

void l2c_update_lru_current_pages_table(uint64_t index) {
  assert(index < L2C_CURRENT_PAGES_TABLE_ENTRIES);
  for (int i = 0; i < L2C_CURRENT_PAGES_TABLE_ENTRIES; i++) {
    if (l2c_current_pages_table[l2c_cpu_id][i].lru < l2c_current_pages_table[l2c_cpu_id][index].lru) { // Found
      l2c_current_pages_table[l2c_cpu_id][i].lru++;
    }
  }
  l2c_current_pages_table[l2c_cpu_id][index].lru = 0;
}

uint64_t l2c_get_lru_current_pages_entry() {
  uint64_t lru = L2C_CURRENT_PAGES_TABLE_ENTRIES;
  for (int i = 0; i < L2C_CURRENT_PAGES_TABLE_ENTRIES; i++) {
    l2c_current_pages_table[l2c_cpu_id][i].lru++;
    if (l2c_current_pages_table[l2c_cpu_id][i].lru == L2C_CURRENT_PAGES_TABLE_ENTRIES) {
      l2c_current_pages_table[l2c_cpu_id][i].lru = 0;
      lru = i;
    }
  }
  assert(lru != L2C_CURRENT_PAGES_TABLE_ENTRIES);
  return lru;
}

int l2c_get_berti_current_pages_table(uint64_t index, uint64_t &ctr) {
  assert(index < L2C_CURRENT_PAGES_TABLE_ENTRIES);
  uint64_t max_score = 0;
  uint64_t berti = 0;
  for (int i = 0; i < L2C_CURRENT_PAGES_TABLE_NUM_BERTI; i++) {
    uint64_t score;
    score = l2c_current_pages_table[l2c_cpu_id][index].berti_ctr[i];
    if (score > max_score) {
      berti = l2c_current_pages_table[l2c_cpu_id][index].berti[i];
      max_score = score;
      ctr = l2c_current_pages_table[l2c_cpu_id][index].berti_ctr[i];
    }
  }
  return berti;
}

void l2c_add_current_pages_table(uint64_t index, uint64_t page_addr, uint64_t ip, uint64_t offset) {
  assert(index < L2C_CURRENT_PAGES_TABLE_ENTRIES);
  l2c_current_pages_table[l2c_cpu_id][index].page_addr = page_addr;
  l2c_current_pages_table[l2c_cpu_id][index].ip = ip;
  l2c_current_pages_table[l2c_cpu_id][index].u_vector = (uint64_t)1 << offset;
  l2c_current_pages_table[l2c_cpu_id][index].first_offset = offset;
  for (int i = 0; i < L2C_CURRENT_PAGES_TABLE_NUM_BERTI; i++) {
    l2c_current_pages_table[l2c_cpu_id][index].berti_ctr[i] = 0;
  }
  l2c_current_pages_table[l2c_cpu_id][index].last_burst = 0;
}

uint64_t l2c_update_demand_current_pages_table(uint64_t index, uint64_t offset) {
  assert(index < L2C_CURRENT_PAGES_TABLE_ENTRIES);
  l2c_current_pages_table[l2c_cpu_id][index].u_vector |= (uint64_t)1 << offset;
  l2c_update_lru_current_pages_table(index);
  return l2c_current_pages_table[l2c_cpu_id][index].ip;
}

void l2c_add_berti_current_pages_table(uint64_t index, int berti) {
  assert(berti != 0);
  assert(index < L2C_CURRENT_PAGES_TABLE_ENTRIES);
  for (int i = 0; i < L2C_CURRENT_PAGES_TABLE_NUM_BERTI; i++) {
    if (l2c_current_pages_table[l2c_cpu_id][index].berti_ctr[i] == 0) {
      l2c_current_pages_table[l2c_cpu_id][index].berti[i] = berti;
      l2c_current_pages_table[l2c_cpu_id][index].berti_ctr[i] = 1;
      break;
    } else if (l2c_current_pages_table[l2c_cpu_id][index].berti[i] == berti) {
      l2c_current_pages_table[l2c_cpu_id][index].berti_ctr[i]++;
      break;
    }
  }
  l2c_update_lru_current_pages_table(index);
}

bool l2c_requested_offset_current_pages_table(uint64_t index, uint64_t offset) {
  assert(index < L2C_CURRENT_PAGES_TABLE_ENTRIES);
  return l2c_current_pages_table[l2c_cpu_id][index].u_vector & ((uint64_t)1 << offset);
}

void l2c_remove_current_table_entry(uint64_t index) {
  l2c_current_pages_table[l2c_cpu_id][index].page_addr = 0;
  l2c_current_pages_table[l2c_cpu_id][index].u_vector = 0;
  l2c_current_pages_table[l2c_cpu_id][index].berti[0] = 0;
}

// PREVIOUS REQUESTS TABLE

#define L2C_PREV_REQUESTS_TABLE_INDEX_BITS 10
#define L2C_PREV_REQUESTS_TABLE_ENTRIES (1 << L2C_PREV_REQUESTS_TABLE_INDEX_BITS)
#define L2C_PREV_REQUESTS_TABLE_MASK (L2C_PREV_REQUESTS_TABLE_ENTRIES - 1)
#define L2C_PREV_REQUESTS_TABLE_NULL_POINTER L2C_CURRENT_PAGES_TABLE_ENTRIES

typedef struct __l2c_prev_request_entry {
  uint64_t page_addr_pointer; // 6 bits
  uint64_t offset; // 6 bits
  uint64_t time; // 16 bits
} l2c_prev_request_entry;

l2c_prev_request_entry l2c_prev_requests_table[NUM_CPUS][L2C_PREV_REQUESTS_TABLE_ENTRIES];
uint64_t l2c_prev_requests_table_head[NUM_CPUS];

void l2c_init_prev_requests_table() {
  l2c_prev_requests_table_head[l2c_cpu_id] = 0;
  for (int i = 0; i < L2C_PREV_REQUESTS_TABLE_ENTRIES; i++) {
    l2c_prev_requests_table[l2c_cpu_id][i].page_addr_pointer = L2C_PREV_REQUESTS_TABLE_NULL_POINTER;
  }
}

uint64_t l2c_find_prev_request_entry(uint64_t pointer, uint64_t offset) {
  for (int i = 0; i < L2C_PREV_REQUESTS_TABLE_ENTRIES; i++) {
    if (l2c_prev_requests_table[l2c_cpu_id][i].page_addr_pointer == pointer && l2c_prev_requests_table[l2c_cpu_id][i].offset == offset) return i;
  }
  return L2C_PREV_REQUESTS_TABLE_ENTRIES;
}

void l2c_add_prev_requests_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
  // First find for coalescing
  if (l2c_find_prev_request_entry(pointer, offset) != L2C_PREV_REQUESTS_TABLE_ENTRIES) return;

  // Allocate a new entry (evict old one if necessary)
  l2c_prev_requests_table[l2c_cpu_id][l2c_prev_requests_table_head[l2c_cpu_id]].page_addr_pointer = pointer;
  l2c_prev_requests_table[l2c_cpu_id][l2c_prev_requests_table_head[l2c_cpu_id]].offset = offset;
  l2c_prev_requests_table[l2c_cpu_id][l2c_prev_requests_table_head[l2c_cpu_id]].time = cycle & L2C_TIME_MASK;
  l2c_prev_requests_table_head[l2c_cpu_id] = (l2c_prev_requests_table_head[l2c_cpu_id] + 1) & L2C_PREV_REQUESTS_TABLE_MASK;
}

void l2c_reset_pointer_prev_requests(uint64_t pointer) {
  for (int i = 0; i < L2C_PREV_REQUESTS_TABLE_ENTRIES; i++) {
    if (l2c_prev_requests_table[l2c_cpu_id][i].page_addr_pointer == pointer) {
      l2c_prev_requests_table[l2c_cpu_id][i].page_addr_pointer = L2C_PREV_REQUESTS_TABLE_NULL_POINTER;
    }
  }
}

uint64_t l2c_get_latency_prev_requests_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
  uint64_t index = l2c_find_prev_request_entry(pointer, offset);
  if (index == L2C_PREV_REQUESTS_TABLE_ENTRIES) return 0;
  return l2c_get_latency(cycle, l2c_prev_requests_table[l2c_cpu_id][index].time);
}

int32_t l2c_get_berti_prev_requests_table(uint64_t addr,uint64_t ip, uint64_t berti_confidence, int current_berti,uint64_t first_offset, int delta, uint32_t depth, uint64_t pointer, uint64_t offset, uint64_t cycle, int *berti) {
  int my_pos = 0;
  uint64_t extra_time = 0;
  int32_t perc_sum = 0;
  uint64_t last_time = l2c_prev_requests_table[l2c_cpu_id][(l2c_prev_requests_table_head[l2c_cpu_id] + L2C_PREV_REQUESTS_TABLE_MASK) & L2C_PREV_REQUESTS_TABLE_MASK].time;
  for (uint64_t i = (l2c_prev_requests_table_head[l2c_cpu_id] + L2C_PREV_REQUESTS_TABLE_MASK) & L2C_PREV_REQUESTS_TABLE_MASK; i != l2c_prev_requests_table_head[l2c_cpu_id]; i = (i + L2C_PREV_REQUESTS_TABLE_MASK) & L2C_PREV_REQUESTS_TABLE_MASK) {
    // Against the time overflow
    if (last_time < l2c_prev_requests_table[l2c_cpu_id][i].time) {
      extra_time = L2C_TIME_OVERFLOW;
    }
    perc_sum = PERCB.perc_predict(first_offset,addr,current_berti,ip,GHR.ip[1], GHR.ip[2], GHR.ip[3], delta, berti_confidence,depth);
    if (perc_sum< PERC_THRESHOLD_HI){
      uint64_t pf_addr = (addr>>LOG2_BLOCK_SIZE+current_berti) << LOG2_BLOCK_SIZE;
      if ((addr & ~(PAGE_SIZE -1)) == (pf_addr & ~(PAGE_SIZE -1)))
        B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,PERC_REJECT,delta,berti_confidence,perc_sum,depth);
    }
    last_time = l2c_prev_requests_table[l2c_cpu_id][i].time;
    if (l2c_prev_requests_table[l2c_cpu_id][i].page_addr_pointer == pointer) {
      if (l2c_prev_requests_table[l2c_cpu_id][i].time <= (cycle & L2C_TIME_MASK) + extra_time) {
        berti[my_pos] = l2c_calculate_stride(l2c_prev_requests_table[l2c_cpu_id][i].offset, offset);
        my_pos++;
        if (my_pos == L2C_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS) return perc_sum;
      }
    }
  }
  berti[my_pos] = 0;
  return perc_sum;
}


// PREVIOUS PREFETCHES TABLE

#define L2C_PREV_PREFETCHES_TABLE_INDEX_BITS 9
#define L2C_PREV_PREFETCHES_TABLE_ENTRIES (1 << L2C_PREV_PREFETCHES_TABLE_INDEX_BITS)
#define L2C_PREV_PREFETCHES_TABLE_MASK (L2C_PREV_PREFETCHES_TABLE_ENTRIES - 1) // 111111111
#define L2C_PREV_PREFETCHES_TABLE_NULL_POINTER L2C_CURRENT_PAGES_TABLE_ENTRIES

// We do not have access to the MSHR, so we aproximate it using this structure.
typedef struct __l2c_prev_prefetch_entry {
  uint64_t page_addr_pointer; // 6 bits
  uint64_t offset; // 6 bits
  uint64_t time_lat; // 16 bits // time if not completed, latency if completed
  bool completed; // 1 bit
} l2c_prev_prefetch_entry;

l2c_prev_prefetch_entry l2c_prev_prefetches_table[NUM_CPUS][L2C_PREV_PREFETCHES_TABLE_ENTRIES]; // 2^9
uint64_t l2c_prev_prefetches_table_head[NUM_CPUS];

void l2c_init_prev_prefetches_table() {
  l2c_prev_prefetches_table_head[l2c_cpu_id] = 0;
  for (int i = 0; i < L2C_PREV_PREFETCHES_TABLE_ENTRIES; i++) { // 2^9
    l2c_prev_prefetches_table[l2c_cpu_id][i].page_addr_pointer = L2C_PREV_PREFETCHES_TABLE_NULL_POINTER;
  }
}

uint64_t l2c_find_prev_prefetch_entry(uint64_t pointer, uint64_t offset) {
  for (int i = 0; i < L2C_PREV_PREFETCHES_TABLE_ENTRIES; i++) { // 2^9
    if (l2c_prev_prefetches_table[l2c_cpu_id][i].page_addr_pointer == pointer && l2c_prev_prefetches_table[l2c_cpu_id][i].offset == offset) return i;
  }
  return L2C_PREV_PREFETCHES_TABLE_ENTRIES; // 2^9
}

void l2c_add_prev_prefetches_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
  // First find for coalescing
  if (l2c_find_prev_prefetch_entry(pointer, offset) != L2C_PREV_PREFETCHES_TABLE_ENTRIES) return;

  // Allocate a new entry (evict old one if necessary)
  l2c_prev_prefetches_table[l2c_cpu_id][l2c_prev_prefetches_table_head[l2c_cpu_id]].page_addr_pointer = pointer;
  l2c_prev_prefetches_table[l2c_cpu_id][l2c_prev_prefetches_table_head[l2c_cpu_id]].offset = offset;
  l2c_prev_prefetches_table[l2c_cpu_id][l2c_prev_prefetches_table_head[l2c_cpu_id]].time_lat = cycle & L2C_TIME_MASK;
  l2c_prev_prefetches_table[l2c_cpu_id][l2c_prev_prefetches_table_head[l2c_cpu_id]].completed = false;
  l2c_prev_prefetches_table_head[l2c_cpu_id] = (l2c_prev_prefetches_table_head[l2c_cpu_id] + 1) & L2C_PREV_PREFETCHES_TABLE_MASK;
}

void l2c_reset_pointer_prev_prefetches(uint64_t pointer) {
  for (int i = 0; i < L2C_PREV_PREFETCHES_TABLE_ENTRIES; i++) {
    if (l2c_prev_prefetches_table[l2c_cpu_id][i].page_addr_pointer == pointer) {
      l2c_prev_prefetches_table[l2c_cpu_id][i].page_addr_pointer = L2C_PREV_PREFETCHES_TABLE_NULL_POINTER;
    }
  }
}

void l2c_reset_entry_prev_prefetches_table(uint64_t pointer, uint64_t offset) {
  uint64_t index = l2c_find_prev_prefetch_entry(pointer, offset);
  if (index != L2C_PREV_PREFETCHES_TABLE_ENTRIES) {
    l2c_prev_prefetches_table[l2c_cpu_id][index].page_addr_pointer = L2C_PREV_PREFETCHES_TABLE_NULL_POINTER;
  }
}

uint64_t l2c_get_and_set_latency_prev_prefetches_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
  uint64_t index = l2c_find_prev_prefetch_entry(pointer, offset);
  if (index == L2C_PREV_PREFETCHES_TABLE_ENTRIES) return 0;
  if (!l2c_prev_prefetches_table[l2c_cpu_id][index].completed) {
    l2c_prev_prefetches_table[l2c_cpu_id][index].time_lat = l2c_get_latency(cycle, l2c_prev_prefetches_table[l2c_cpu_id][index].time_lat);
    l2c_prev_prefetches_table[l2c_cpu_id][index].completed = true;
  }
  return l2c_prev_prefetches_table[l2c_cpu_id][index].time_lat;
}

uint64_t l2c_get_latency_prev_prefetches_table(uint64_t pointer, uint64_t offset) {
  uint64_t index = l2c_find_prev_prefetch_entry(pointer, offset);
  if (index == L2C_PREV_PREFETCHES_TABLE_ENTRIES) return 0;
  if (!l2c_prev_prefetches_table[l2c_cpu_id][index].completed) return 0;
  return l2c_prev_prefetches_table[l2c_cpu_id][index].time_lat;
}


// RECORD PAGES TABLE

//#define L2C_RECORD_PAGES_TABLE_INDEX_BITS 9
#define L2C_RECORD_PAGES_TABLE_ENTRIES (((1 << 9) + (1 << 8)) - 1) // Null pointer for ip table
#define L2C_TRUNCATED_PAGE_ADDR_BITS 32 // 4 bytes
#define L2C_TRUNCATED_PAGE_ADDR_MASK (((uint64_t)1 << L2C_TRUNCATED_PAGE_ADDR_BITS) -1)

typedef struct __l2c_record_page_entry {
  uint64_t page_addr; // 4 bytes
  uint64_t u_vector; // 8 bytes
  uint64_t first_offset; // 6 bits
  int berti; // 7 bits
  uint64_t lru; // 10 bits
} l2c_record_page_entry;

l2c_record_page_entry l2c_record_pages_table[NUM_CPUS][L2C_RECORD_PAGES_TABLE_ENTRIES];

void l2c_init_record_pages_table() {
  for (int i = 0; i < L2C_RECORD_PAGES_TABLE_ENTRIES; i++) {
    l2c_record_pages_table[l2c_cpu_id][i].page_addr = 0;
    l2c_record_pages_table[l2c_cpu_id][i].u_vector = 0;
    l2c_record_pages_table[l2c_cpu_id][i].lru = i;
  }
}

uint64_t l2c_get_lru_record_pages_entry() {
  uint64_t lru = L2C_RECORD_PAGES_TABLE_ENTRIES;
  for (int i = 0; i < L2C_RECORD_PAGES_TABLE_ENTRIES; i++) {
    l2c_record_pages_table[l2c_cpu_id][i].lru++;
    if (l2c_record_pages_table[l2c_cpu_id][i].lru == L2C_RECORD_PAGES_TABLE_ENTRIES) {
      l2c_record_pages_table[l2c_cpu_id][i].lru = 0;
      lru = i;
    }
  }
  assert(lru != L2C_RECORD_PAGES_TABLE_ENTRIES);
  return lru;
}

void l2c_update_lru_record_pages_table(uint64_t index) {
  assert(index < L2C_RECORD_PAGES_TABLE_ENTRIES);
  for (int i = 0; i < L2C_RECORD_PAGES_TABLE_ENTRIES; i++) {
    if (l2c_record_pages_table[l2c_cpu_id][i].lru < l2c_record_pages_table[l2c_cpu_id][index].lru) { // Found
      l2c_record_pages_table[l2c_cpu_id][i].lru++;
    }
  }
  l2c_record_pages_table[l2c_cpu_id][index].lru = 0;
}

void l2c_add_record_pages_table(uint64_t index, uint64_t page_addr, uint64_t vector, uint64_t first_offset, int berti) {
  assert(index < L2C_RECORD_PAGES_TABLE_ENTRIES);
  l2c_record_pages_table[l2c_cpu_id][index].page_addr = page_addr & L2C_TRUNCATED_PAGE_ADDR_MASK;
  l2c_record_pages_table[l2c_cpu_id][index].u_vector = vector;
  l2c_record_pages_table[l2c_cpu_id][index].first_offset = first_offset;
  l2c_record_pages_table[l2c_cpu_id][index].berti = berti;
  l2c_update_lru_record_pages_table(index);
}

uint64_t l2c_get_entry_record_pages_table(uint64_t page_addr, uint64_t first_offset) {
  uint64_t trunc_page_addr = page_addr & L2C_TRUNCATED_PAGE_ADDR_MASK;
  for (int i = 0; i < L2C_RECORD_PAGES_TABLE_ENTRIES; i++) {
    if (l2c_record_pages_table[l2c_cpu_id][i].page_addr == trunc_page_addr && l2c_record_pages_table[l2c_cpu_id][i].first_offset == first_offset) { // Found
      return i;
    }
  }
  return L2C_RECORD_PAGES_TABLE_ENTRIES;
}

uint64_t l2c_get_entry_record_pages_table(uint64_t page_addr) {
  uint64_t trunc_page_addr = page_addr & L2C_TRUNCATED_PAGE_ADDR_MASK;
  for (int i = 0; i < L2C_RECORD_PAGES_TABLE_ENTRIES; i++) {
    if (l2c_record_pages_table[l2c_cpu_id][i].page_addr == trunc_page_addr) { // Found
      return i;
    }
  }
  return L2C_RECORD_PAGES_TABLE_ENTRIES;
}

void l2c_copy_entries_record_pages_table(uint64_t index_from, uint64_t index_to) {
  assert(index_from < L2C_RECORD_PAGES_TABLE_ENTRIES);
  assert(index_to < L2C_RECORD_PAGES_TABLE_ENTRIES);
  l2c_record_pages_table[l2c_cpu_id][index_to].page_addr = l2c_record_pages_table[l2c_cpu_id][index_from].page_addr;
  l2c_record_pages_table[l2c_cpu_id][index_to].u_vector = l2c_record_pages_table[l2c_cpu_id][index_from].u_vector;
  l2c_record_pages_table[l2c_cpu_id][index_to].first_offset = l2c_record_pages_table[l2c_cpu_id][index_from].first_offset;
  l2c_record_pages_table[l2c_cpu_id][index_to].berti = l2c_record_pages_table[l2c_cpu_id][index_from].berti;
  l2c_update_lru_record_pages_table(index_to);
}


// IP TABLE

#define L2C_IP_TABLE_INDEX_BITS 10
#define L2C_IP_TABLE_ENTRIES (1 << L2C_IP_TABLE_INDEX_BITS)
#define L2C_IP_TABLE_INDEX_MASK (L2C_IP_TABLE_ENTRIES - 1)
#define L2C_IP_TABLE_NULL_POINTER L2C_RECORD_PAGES_TABLE_ENTRIES

uint64_t l2c_ip_table[NUM_CPUS][L2C_IP_TABLE_ENTRIES]; // 10 bits

void l2c_init_ip_table() {
  for (int i = 0; i < L2C_IP_TABLE_ENTRIES; i++) {
    l2c_ip_table[l2c_cpu_id][i] = L2C_IP_TABLE_NULL_POINTER;
  }
}
// TABLE MOVEMENTS

// Sumarizes the content to the current page to be evicted
// From all timely requests found, we record the best
void l2c_record_current_page(uint64_t index_current) {
  if (l2c_current_pages_table[l2c_cpu_id][index_current].u_vector) { // Valid entry
    uint64_t record_index = l2c_ip_table[l2c_cpu_id][l2c_current_pages_table[l2c_cpu_id][index_current].ip & L2C_IP_TABLE_INDEX_MASK];
    assert(record_index < L2C_RECORD_PAGES_TABLE_ENTRIES);
    uint64_t confidence;
    l2c_add_record_pages_table(record_index,l2c_current_pages_table[l2c_cpu_id][index_current].page_addr,l2c_current_pages_table[l2c_cpu_id][index_current].u_vector,l2c_current_pages_table[l2c_cpu_id][index_current].first_offset,l2c_get_berti_current_pages_table(index_current, confidence));
  }
}

// INTERFACE

void CACHE::l2c_prefetcher_initialize(){
  l2c_cpu_id = cpu;
  cout << "CPU " << cpu << " L2C Berti prefetcher" << endl;

  l2c_init_current_pages_table();
  l2c_init_prev_requests_table();
  l2c_init_prev_prefetches_table();
  l2c_init_record_pages_table();
  l2c_init_ip_table();
}

uint32_t Berti_l2c_prefetcher_operate(CACHE *cache,uint64_t addr, uint64_t ip, uint64_t berti_confidence, int current_berti, uint64_t first_offset, int delta, uint32_t depth, uint8_t cache_hit, uint8_t type, uint32_t metadata_in){
  l2c_cpu_id = cache -> cpu;
  uint64_t line_addr = addr >> LOG2_BLOCK_SIZE;
  uint64_t page_addr = line_addr >> L2C_PAGE_BLOCKS_BITS;
  uint64_t offset = line_addr & L2C_PAGE_OFFSET_MASK;

  // Update current pages table
  // Find the entry
  uint64_t index = l2c_get_current_pages_entry(page_addr);

  // If not accessed recently
  if (index == L2C_CURRENT_PAGES_TABLE_ENTRIES || !l2c_requested_offset_current_pages_table(index, offset)) {

      if (index < L2C_CURRENT_PAGES_TABLE_ENTRIES) { // Found

        // If offset found, already requested, so return;
        if (l2c_requested_offset_current_pages_table(index, offset)) return metadata_in;

        uint64_t first_ip = l2c_update_demand_current_pages_table(index, offset);
        assert(l2c_ip_table[l2c_cpu_id][first_ip & L2C_IP_TABLE_INDEX_MASK] != L2C_IP_TABLE_NULL_POINTER);

        // Update berti
        if (cache_hit) {
          uint64_t pref_latency = l2c_get_latency_prev_prefetches_table(index, offset);
          if (pref_latency != 0) {
            // Find berti distance from pref_latency cycles before
            int berti[L2C_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS];
            l2c_get_berti_prev_requests_table(addr, ip, berti_confidence,current_berti,first_offset,delta,depth,index, offset, current_core_cycle[cache->cpu] - pref_latency, berti);
            for (int i = 0; i < L2C_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS; i++) {
              if (berti[i] == 0) break;
              assert(abs(berti[i]) < L2C_PAGE_BLOCKS);
              l2c_add_berti_current_pages_table(index, berti[i]);
            }

            // Eliminate a prev prefetch since it has been used
            l2c_reset_entry_prev_prefetches_table(index, offset);
          }
        }

        if (first_ip != ip) {
          // Assign same pointer to group IPs
          l2c_ip_table[l2c_cpu_id][ip & L2C_IP_TABLE_INDEX_MASK] = l2c_ip_table[l2c_cpu_id][first_ip & L2C_IP_TABLE_INDEX_MASK];
        }
      }
      else { // Not found: Add entry

        // Find victim and clear pointers to it
        uint64_t victim_index = l2c_get_lru_current_pages_entry(); // already updates lru
        assert(victim_index < L2C_CURRENT_PAGES_TABLE_ENTRIES);
        l2c_reset_pointer_prev_requests(victim_index); // Not valid anymore
        l2c_reset_pointer_prev_prefetches(victim_index); // Not valid anymore

        // Copy victim to record table
        l2c_record_current_page(victim_index);

        // Add new current page
        index = victim_index;
        l2c_add_current_pages_table(index, page_addr, ip & L2C_IP_TABLE_INDEX_MASK, offset);

        // Set pointer in IP table
        uint64_t index_record = l2c_get_entry_record_pages_table(page_addr, offset);
        // The ip pointer is null
        if (l2c_ip_table[l2c_cpu_id][ip & L2C_IP_TABLE_INDEX_MASK] == L2C_IP_TABLE_NULL_POINTER) {
          if (index_record == L2C_RECORD_PAGES_TABLE_ENTRIES) { // Page not recorded
            // Get free record page pointer.
            uint64_t new_pointer = l2c_get_lru_record_pages_entry();
            l2c_ip_table[l2c_cpu_id][ip & L2C_IP_TABLE_INDEX_MASK] = new_pointer;
          }
          else {
            l2c_ip_table[l2c_cpu_id][ip & L2C_IP_TABLE_INDEX_MASK] = index_record;
          }
        }
        else if (l2c_ip_table[l2c_cpu_id][ip & L2C_IP_TABLE_INDEX_MASK] != index_record) {
          // If the current IP is valid, but points to another address
          // we replicate it in another record entry (lru)
          // such that the recorded page is not deleted when the current entry summarizes
          uint64_t new_pointer = l2c_get_lru_record_pages_entry();
          l2c_copy_entries_record_pages_table(l2c_ip_table[l2c_cpu_id][ip & L2C_IP_TABLE_INDEX_MASK], new_pointer);
          l2c_ip_table[l2c_cpu_id][ip & L2C_IP_TABLE_INDEX_MASK] = new_pointer;
        }
      }

      l2c_add_prev_requests_table(index, offset, current_core_cycle[cache->cpu]);

      // PREDICT
      uint64_t u_vector = 0;
      uint64_t first_offset = l2c_current_pages_table[l2c_cpu_id][index].first_offset;
      int berti = 0;
      bool recorded = false;

      uint64_t ip_pointer = l2c_ip_table[l2c_cpu_id][ip & L2C_IP_TABLE_INDEX_MASK];
      uint64_t pgo_pointer = l2c_get_entry_record_pages_table(page_addr, first_offset);
      uint64_t pg_pointer = l2c_get_entry_record_pages_table(page_addr);
      uint64_t berti_confidence = 0;
      int current_berti = l2c_get_berti_current_pages_table(index, berti_confidence);
      uint64_t match_confidence = 0;

      // If match with current page+first_offset, use record
      if (pgo_pointer != L2C_RECORD_PAGES_TABLE_ENTRIES  && (l2c_record_pages_table[l2c_cpu_id][pgo_pointer].u_vector | l2c_current_pages_table[l2c_cpu_id][index].u_vector) == l2c_record_pages_table[l2c_cpu_id][pgo_pointer].u_vector) {
          u_vector =  l2c_record_pages_table[l2c_cpu_id][pgo_pointer].u_vector;
          berti =  l2c_record_pages_table[l2c_cpu_id][pgo_pointer].berti;
          match_confidence = 1; // High confidence
          recorded = true;
        } else
        // If match with current ip+first_offset, use record
        if (l2c_record_pages_table[l2c_cpu_id][ip_pointer].first_offset == first_offset && (l2c_record_pages_table[l2c_cpu_id][ip_pointer].u_vector | l2c_current_pages_table[l2c_cpu_id][index].u_vector) == l2c_record_pages_table[l2c_cpu_id][ip_pointer].u_vector) {
            u_vector =  l2c_record_pages_table[l2c_cpu_id][ip_pointer].u_vector;
            berti =  l2c_record_pages_table[l2c_cpu_id][ip_pointer].berti;
            match_confidence = 1; // High confidence
            recorded = true;
        } else
          // If no exact match, trust current if it has already a berti
          if (current_berti != 0 && berti_confidence >= L2C_BERTI_CTR_MED_HIGH_CONFIDENCE) { // Medium-High confidence
            u_vector =  l2c_current_pages_table[l2c_cpu_id][index].u_vector;
            berti = current_berti;
          } else
          // If match with current page, use record
          if (pg_pointer != L2C_RECORD_PAGES_TABLE_ENTRIES) { // Medium confidence
            u_vector =  l2c_record_pages_table[l2c_cpu_id][pg_pointer].u_vector;
            berti =  l2c_record_pages_table[l2c_cpu_id][pg_pointer].berti;
            recorded = true;
          } else
          // If match with current ip, use record
          if (l2c_record_pages_table[l2c_cpu_id][ip_pointer].u_vector) { // Medium confidence
            u_vector =  l2c_record_pages_table[l2c_cpu_id][ip_pointer].u_vector;
            berti =  l2c_record_pages_table[l2c_cpu_id][ip_pointer].berti;
            recorded = true;
          }

          // Burst for the first access of a page or if pending bursts
          if (first_offset == offset || l2c_current_pages_table[l2c_cpu_id][index].last_burst != 0) {
            uint64_t first_burst;
            if (l2c_current_pages_table[l2c_cpu_id][index].last_burst != 0) {
              first_burst = l2c_current_pages_table[l2c_cpu_id][index].last_burst;
              l2c_current_pages_table[l2c_cpu_id][index].last_burst = 0;
            }
            else if (berti >= 0) {
              first_burst = offset + 1;
            }
            else {
              first_burst = offset - 1;
            }
            if (recorded && match_confidence) {
              int bursts = 0;
              if (berti > 0) {
                for (uint64_t i = first_burst; i < offset+berti; i++) {
                  if (i >= L2C_PAGE_BLOCKS) break; // Stay in the page
                  // Only if previously requested and not demanded
                  uint64_t pf_line_addr = (page_addr << L2C_PAGE_BLOCKS_BITS) | i;
                  uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
                  uint64_t pf_page_addr = pf_line_addr >> L2C_PAGE_BLOCKS_BITS;
                  uint64_t pf_offset = pf_line_addr & L2C_PAGE_OFFSET_MASK;
                  //if ((((uint64_t)1 << i) & u_vector) && !l2c_requested_offset_current_pages_table(index, pf_offset)) {
                    if (cache -> PQ.occupancy < cache -> PQ.SIZE && bursts < L2C_MAX_NUM_BURST_PREFETCHES) {
                      int delta = addr-GHR.addr[1];
                      int perc_sum = PERCB.perc_predict(first_offset,addr,current_berti,ip,GHR.ip[1],GHR.ip[2],GHR.ip[3],delta,berti_confidence,0);
                      FILTER_REQUEST fill_level = (perc_sum >= PERC_THRESHOLD_HI) ? L2C_PREFETCH : LLC_PREFETCH;
                      int fill = (perc_sum >= PERC_THRESHOLD_HI)? FILL_L2: FILL_LLC;
                      bool prefetched = false;
                      if (B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,fill_level,delta,berti_confidence,perc_sum,0)) {
                        prefetched = cache -> prefetch_line(ip, addr, pf_addr, fill, 0);
                      }
                      else B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,PERC_REJECT,delta,berti_confidence,perc_sum,0);
                      if (prefetched) {
                        assert(pf_page_addr == page_addr);
                        l2c_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cache->cpu]);
                        bursts++;
                      }
                    } else { // record last burst
                      l2c_current_pages_table[l2c_cpu_id][index].last_burst = i;
                      break;
                    }
                  //}
                }
              }
              else if (berti < 0) {
                for (int i = first_burst; i > ((int)offset)+berti; i--) {
                  if (i < 0) break; // Stay in the page
                  // Only if previously requested and not demanded
                  uint64_t pf_line_addr = (page_addr << L2C_PAGE_BLOCKS_BITS) | i;
                  uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
                  uint64_t pf_page_addr = pf_line_addr >> L2C_PAGE_BLOCKS_BITS;
                  uint64_t pf_offset = pf_line_addr & L2C_PAGE_OFFSET_MASK;
                  //if ((((uint64_t)1 << i) & u_vector) && !l2c_requested_offset_current_pages_table(index, pf_offset)) {
                    if (cache -> PQ.occupancy < cache -> PQ.SIZE && bursts < L2C_MAX_NUM_BURST_PREFETCHES) {
                      int delta = addr-GHR.addr[1];
                      int perc_sum = PERCB.perc_predict(first_offset,addr,current_berti,ip,GHR.ip[1],GHR.ip[2],GHR.ip[3],delta,berti_confidence,0);
                      FILTER_REQUEST fill_level = (perc_sum >= PERC_THRESHOLD_HI) ? L2C_PREFETCH: LLC_PREFETCH;
                      int fill = (perc_sum >= PERC_THRESHOLD_HI)? FILL_L2: FILL_LLC;
                      bool prefetched = false;
                      if (B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,fill_level,delta,berti_confidence,perc_sum,0)) {
                        prefetched =  cache -> prefetch_line(ip, addr, pf_addr, fill, 0);
                      }
                      else B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,PERC_REJECT,delta,berti_confidence,perc_sum,0);
                      if (prefetched) {
                        assert(pf_page_addr == page_addr);
                        l2c_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cache->cpu]);
                        bursts++;
                      }
                    } else { // record last burst
                      l2c_current_pages_table[l2c_cpu_id][index].last_burst = i;
                      break;
                    }
                  //}
                }
              }
              else { // berti == 0 (zig zag of all)
                for (int i = first_burst, j = (first_offset << 1) - i; i < L2C_PAGE_BLOCKS || j >= 0; i++, j = (first_offset << 1) - i) {
                  // Only if previously requested and not demanded
                  // Dir ++
                  uint64_t pf_line_addr = (page_addr << L2C_PAGE_BLOCKS_BITS) | i;
                  uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
                  uint64_t pf_page_addr = pf_line_addr >> L2C_PAGE_BLOCKS_BITS;
                  uint64_t pf_offset = pf_line_addr & L2C_PAGE_OFFSET_MASK;
                  //if ((((uint64_t)1 << i) & u_vector) && !l2c_requested_offset_current_pages_table(index, pf_offset)) {
                    if (cache -> PQ.occupancy < cache -> PQ.SIZE && bursts < L2C_MAX_NUM_BURST_PREFETCHES) {
                      int delta = addr-GHR.addr[1];
                      int perc_sum = PERCB.perc_predict(first_offset,addr,current_berti,ip,GHR.ip[1],GHR.ip[2],GHR.ip[3],delta,berti_confidence,0);
                      FILTER_REQUEST fill_level = (perc_sum >= PERC_THRESHOLD_HI) ? L2C_PREFETCH: LLC_PREFETCH;
                      int fill = (perc_sum >= PERC_THRESHOLD_HI)? FILL_L2: FILL_LLC;
                      bool prefetched = false;
                      if (B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,fill_level,delta,berti_confidence,perc_sum,0)) {
                        prefetched =  cache -> prefetch_line(ip, addr, pf_addr, fill, 0);
                      }
                      else B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,PERC_REJECT,delta,berti_confidence,perc_sum,0);
                      if (prefetched) {
                        assert(pf_page_addr == page_addr);
                        l2c_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cache->cpu]);
                        bursts++;
                      }
                    } else { // record last burst
                      l2c_current_pages_table[l2c_cpu_id][index].last_burst = i;
                      break;
                    }
                  //}
                  // Dir --
                  pf_line_addr = (page_addr << L2C_PAGE_BLOCKS_BITS) | j;
                  pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
                  pf_page_addr = pf_line_addr >> L2C_PAGE_BLOCKS_BITS;
                  pf_offset = pf_line_addr & L2C_PAGE_OFFSET_MASK;
                  //if ((((uint64_t)1 << j) & u_vector)&& !l2c_requested_offset_current_pages_table(index, pf_offset)) {
                    //if (cache -> PQ.occupancy < cache -> PQ.SIZE && bursts < L2C_MAX_NUM_BURST_PREFETCHES) {
                    int delta = addr-GHR.addr[1];
                    int perc_sum = PERCB.perc_predict(first_offset,addr,current_berti,ip,GHR.ip[1],GHR.ip[2],GHR.ip[3],delta,berti_confidence,0);
                    FILTER_REQUEST fill_level = (perc_sum >= PERC_THRESHOLD_HI) ? L2C_PREFETCH: LLC_PREFETCH;
                    int fill = (perc_sum >= PERC_THRESHOLD_HI)? FILL_L2: FILL_LLC;
                    bool prefetched = false;
                    if (B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,fill_level,delta,berti_confidence,perc_sum,0)) {
                      prefetched =cache -> prefetch_line(ip, addr, pf_addr, fill, 0);
                    }
                    else B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,PERC_REJECT,delta,berti_confidence,perc_sum,0);
                    if (prefetched) {
                        assert(pf_page_addr == page_addr);
                        l2c_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cache->cpu]);
                        bursts++;
                      }
                    //}
                  //}
                }
              }
            }
            else { // not recorded
            }
          }

          if (berti != 0) {
            // TODO: Remove prefetch if already used!
            uint64_t pf_line_addr = line_addr + berti;
            uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
            uint64_t pf_page_addr = pf_line_addr >> L2C_PAGE_BLOCKS_BITS;
            uint64_t pf_offset = pf_line_addr & L2C_PAGE_OFFSET_MASK;
            //if (!l2c_requested_offset_current_pages_table(index, pf_offset) // Only prefetch if not demanded
            //&& (!match_confidence || (((uint64_t)1 << pf_offset) & u_vector))) { // And prev. accessed
            int delta = addr-GHR.addr[1];
            int perc_sum = PERCB.perc_predict(first_offset,addr,current_berti,ip,GHR.ip[1],GHR.ip[2],GHR.ip[3],delta,berti_confidence,0);
            FILTER_REQUEST fill_level = (perc_sum >= PERC_THRESHOLD_HI) ? L2C_PREFETCH: LLC_PREFETCH;
            int fill = (perc_sum >= PERC_THRESHOLD_HI)? FILL_L2: FILL_LLC;
            bool prefetched = false;
            if (B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,fill_level,delta,berti_confidence,perc_sum,0)) {
              prefetched =cache -> prefetch_line(ip, addr, pf_addr, fill, 0);
            }
            else B_FILTER.check(pf_addr,first_offset,addr,current_berti,ip,PERC_REJECT,delta,berti_confidence,perc_sum,0);
            if (prefetched) {
                assert(pf_page_addr == page_addr);
                l2c_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cache->cpu]);
              }
            //}
          }
        }
    return metadata_in;
}

uint32_t SPP_l2c_prefetcher_operate(CACHE * cache, uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in){
  // addr is a byte address. It can be used to find out cache_line address, page address and page_offset

  uint64_t page = addr >> LOG2_PAGE_SIZE;  // page no.
  uint32_t page_offset = (addr >> LOG2_BLOCK_SIZE) & (PAGE_SIZE / BLOCK_SIZE - 1),  // page offset withing a page
  last_sig = 0,
  curr_sig = 0,
  confidence_q[100*L2C_MSHR_SIZE],
  depth = 0;

  int32_t  delta = 0,delta_q[100*L2C_MSHR_SIZE],perc_sum_q[100*L2C_MSHR_SIZE]; // what are they for?

  // initialization: setting to 0
  for (uint32_t i = 0; i < 100*L2C_MSHR_SIZE; i++){
    confidence_q[i] = 0;
    delta_q[i] = 0;
    perc_sum_q[i] = 0;
  }

  confidence_q[0] = 100;	// the confidence of 0 what?
  GHR.global_accuracy = GHR.pf_issued ? ((100 * GHR.pf_useful) / GHR.pf_issued)  : 0; // spp specific

  for (int i = PAGES_TRACKED-1; i>0; i--) { // N down to 1
    GHR.page_tracker[i] = GHR.page_tracker[i-1];
  }

  GHR.page_tracker[0] = page;

  int distinct_pages = 0;	// spp specific
  uint8_t num_pf = 0;	// what is this? maybe no. of prefetches
  // counting no. of distinct_pages
  for (int i=0; i < PAGES_TRACKED; i++) {
    int j;
    for (j=0; j<i; j++) {
      if (GHR.page_tracker[i] == GHR.page_tracker[j]) break;
    }
    if (i==j) distinct_pages++;
  }
  //cout << "Distinct Pages: " << distinct_pages << endl;

  // Stage 1: Read and update a sig stored in ST signature table
  // last_sig and delta are used to update (sig, delta) correlation in PT
  // curr_sig is used to read prefetch candidates in PT (pattern table). curr_sig is calculated using last_sig and delta

  ST.read_and_update_sig(page, page_offset, last_sig, curr_sig, delta); 	// spp specific

  // Also check the prefetch filter in parallel to update global accuracy counters
  FILTER.check(addr, 0, 0, FILTER_REQUEST_SPP.L2C_DEMAND, 0, 0, 0, 0, 0, 0); // how do we know L2C_DEMAND		####################################filter_type###################


  // Stage 2: Update delta patterns stored in PT
  if (last_sig) PT.update_pattern(last_sig, delta);

  // Stage 3: Start prefetching
  uint64_t base_addr = addr;
  uint64_t curr_ip = ip;
  uint32_t lookahead_conf = 100,
  pf_q_head = 0,
  pf_q_tail = 0;
  uint8_t  do_lookahead = 0;
  int32_t  prev_delta = 0;

  uint64_t train_addr  = addr;
  int32_t  train_delta = 0;

  #ifdef LOOKAHEAD_ON
  do {
    #endif
    uint32_t lookahead_way = PT_WAY;

    train_addr  = addr;
    train_delta = prev_delta;
    // Remembering the original addr here and accumulating the deltas in lookahead stages

    // Read the PT. Also passing info required for perceptron inferencing as PT calls perc_predict()
    PT.read_pattern(curr_sig, delta_q, confidence_q, perc_sum_q, lookahead_way, lookahead_conf, pf_q_tail, depth, addr, base_addr, train_addr, curr_ip, train_delta, last_sig, cache->PQ.occupancy, cache->PQ.SIZE, cache->MSHR.occupancy, cache->MSHR.SIZE);

    do_lookahead = 0;
    for (uint32_t i = pf_q_head; i < pf_q_tail; i++) {

      uint64_t pf_addr = (base_addr & ~(BLOCK_SIZE - 1)) + (delta_q[i] << LOG2_BLOCK_SIZE);

      int32_t perc_sum   = perc_sum_q[i];

      FILTER_REQUEST_SPP fill_level = (perc_sum >= PERC_THRESHOLD_HI) ? SPP_L2C_PREFETCH : SPP_LLC_PREFETCH;

      if ((addr & ~(PAGE_SIZE - 1)) == (pf_addr & ~(PAGE_SIZE - 1))) { // Prefetch request is in the same physical page

        // Filter checks for redundancy and returns FALSE if redundant
        // Else it returns TRUE and logs the features for future retrieval

        if ( num_pf < ceil(((cache->PQ.SIZE)/distinct_pages)) ) {
          if (FILTER.check(pf_addr, train_addr, curr_ip, fill_level, train_delta + delta_q[i], last_sig, curr_sig, confidence_q[i], perc_sum, (depth-1))) {

            //[DO NOT TOUCH]:
            // Use addr (not base_addr) to obey the same physical page boundary

            cache->prefetch_line(ip, addr, pf_addr, ((fill_level == SPP_L2C_PREFETCH) ? FILL_L2 : FILL_LLC),5);
            num_pf++;

            //FILTER.valid_reject[quotient] = 0;
            if (fill_level == SPP_L2C_PREFETCH) {
              GHR.pf_issued++;
              if (GHR.pf_issued > GLOBAL_COUNTER_MAX) {
                GHR.pf_issued >>= 1;
                GHR.pf_useful >>= 1;
              }
              SPP_DP (cout << "[ChampSim] SPP L2 prefetch issued GHR.pf_issued: " << GHR.pf_issued << " GHR.pf_useful: " << GHR.pf_useful << endl;);
            }
          }
        }
      }
      else { // Prefetch request is crossing the physical page boundary
        #ifdef GHR_ON
        // Store this prefetch request in GHR to bootstrap SPP learning when we see a ST miss (i.e., accessing a new page)
        GHR.update_entry(curr_sig, confidence_q[i], (pf_addr >> LOG2_BLOCK_SIZE) & 0x3F, delta_q[i]);
        #endif
      }

      do_lookahead = 1;
      pf_q_head++;
    }

    // Update base_addr and curr_sig
    if (lookahead_way < PT_WAY) {
      uint32_t set = get_hash(curr_sig) % PT_SET;
      base_addr += (PT.delta[set][lookahead_way] << LOG2_BLOCK_SIZE);
      prev_delta += PT.delta[set][lookahead_way];

      // PT.delta uses a 7-bit sign magnitude representation to generate sig_delta
      //int sig_delta = (PT.delta[set][lookahead_way] < 0) ? ((((-1) * PT.delta[set][lookahead_way]) & 0x3F) + 0x40) : PT.delta[set][lookahead_way];
      int sig_delta = (PT.delta[set][lookahead_way] < 0) ? (((-1) * PT.delta[set][lookahead_way]) + (1 << (SIG_DELTA_BIT - 1))) : PT.delta[set][lookahead_way];
      curr_sig = ((curr_sig << SIG_SHIFT) ^ sig_delta) & SIG_MASK;
    }
    #ifdef LOOKAHEAD_ON
  } while (do_lookahead);
  #endif

  return metadata_in;
}

uint32_t CACHE::l2c_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint32_t metadata_in){
  for (int i = 31; i>0; i--) {
    GHR.ip[i] = GHR.ip[i-1];
    GHR.addr[i] = GHR.addr[i-1];
  }
  GHR.ip[0] = ip;
  GHR.addr[0] = addr;

  int delta = addr-GHR.addr[1];
  uint32_t depth = 0;
  int perc_sum_berti = 0;
  int perc_sum_spp = 0;

  l2c_cpu_id = cpu;
  uint64_t line_addr = addr >> LOG2_BLOCK_SIZE;
  uint64_t page_addr = line_addr >> L2C_PAGE_BLOCKS_BITS;
  uint64_t offset = line_addr & L2C_PAGE_OFFSET_MASK;
  uint64_t first_offset = 0;
  int current_berti = 0;
  uint64_t berti_confidence = 0;

  // Update current pages table
  // Find the entry
  uint64_t index = l2c_get_current_pages_entry(page_addr);
  uint64_t page = addr >> LOG2_PAGE_SIZE;
  uint32_t page_offset = (addr >> LOG2_BLOCK_SIZE) & (PAGE_SIZE / BLOCK_SIZE -1),
  last_sig = 0,
  curr_sig = 0,
  confidence_q[100*L2C_MSHR_SIZE];
  int32_t delta_spp = 0, delta_q[100*L2C_MSHR_SIZE], perc_sum_q[100*L2C_MSHR_SIZE];

  for(uint32_t i = 0; i<100*L2C_MSHR_SIZE; i++) {
    confidence_q[i] = 0;
    delta_q[i] = 0;
    perc_sum_q[i] = 0;
  }

  confidence_q[0] = 100;
  ST.read_and_update_sig(page, page_offset, last_sig, curr_sig, delta_spp);
  FILTER.check(addr,0,0,L2C_DEMAND, 0,0,0,0,0,0);
  if(last_sig) PT.update_pattern(last_sig, delta);
  uint64_t base_addr = addr;
  uint64_t curr_ip = ip;
  uint32_t lookahead_conf = 100,
  pf_q_head = 0,
  pf_q_tail = 0;

  uint8_t  do_lookahead = 0;
  int32_t  prev_delta = 0;

  uint64_t train_addr  = addr;
  int32_t  train_delta = 0;
  uint32_t lookahead_way = PT_WAY;

  train_addr  = addr;
  train_delta = prev_delta;
  PT.read_pattern(curr_sig, delta_q, confidence_q, perc_sum_q, lookahead_way, lookahead_conf, pf_q_tail, depth, addr, base_addr, train_addr, curr_ip, train_delta, last_sig, PQ.occupancy, PQ.SIZE,MSHR.occupancy, MSHR.SIZE);
  int max = -1000000;
  for (int value : perc_sum_q){
    if (value>max) max = value;
  }

  perc_sum_spp = max ;

  if (index == L2C_CURRENT_PAGES_TABLE_ENTRIES || !l2c_requested_offset_current_pages_table(index, offset)) {

      if (index < L2C_CURRENT_PAGES_TABLE_ENTRIES) { // Found
        uint64_t first_ip = l2c_update_demand_current_pages_table(index, offset);
        assert(l2c_ip_table[l2c_cpu_id][first_ip & L2C_IP_TABLE_INDEX_MASK] != L2C_IP_TABLE_NULL_POINTER);
        first_offset = l2c_current_pages_table[l2c_cpu_id][index].first_offset;
        berti_confidence = 0;
        current_berti = l2c_get_berti_current_pages_table(index, berti_confidence);
        // Update berti
        depth = 0;
        delta = addr - GHR.addr[1];
        if (cache_hit) {
          uint64_t pref_latency = l2c_get_latency_prev_prefetches_table(index, offset);
            // Find berti distance from pref_latency cycles before
            int berti[L2C_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS];
            perc_sum_berti = l2c_get_berti_prev_requests_table(addr,ip,berti_confidence, current_berti,first_offset,delta,depth,index, offset, current_core_cycle[cpu] - pref_latency, berti);
            // TODO: COMPARE THE PERC_SUM_BERTI
        }
      }
    }
  if(perc_sum_berti>= perc_sum_spp)
    Berti_l2c_prefetcher_operate(this,addr,ip,berti_confidence,current_berti,first_offset,delta,depth,cache_hit,type,metadata_in);
  else SPP_l2c_prefetcher_operate(this, addr,ip,cache_hit,type, metadata_in);
}

void CACHE::l2c_prefetcher_final_stats(){
  cout << "CPU " << cpu << " L2C berti prefetcher final stats" << endl;
}

uint32_t CACHE::l2c_prefetcher_cache_fill(uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, uint32_t metadata_in){
    l2c_cpu_id = cpu;
    uint64_t line_addr = (addr >> LOG2_BLOCK_SIZE);
    uint64_t page_addr = line_addr >> L2C_PAGE_BLOCKS_BITS;
    uint64_t offset = line_addr & L2C_PAGE_OFFSET_MASK;

    uint64_t pointer_prev = l2c_get_current_pages_entry(page_addr);

    if (pointer_prev < L2C_CURRENT_PAGES_TABLE_ENTRIES) { // Not found, not entry in prev requests
      uint64_t pref_latency = l2c_get_and_set_latency_prev_prefetches_table(pointer_prev, offset, current_core_cycle[cpu]);
      uint64_t demand_latency = l2c_get_latency_prev_requests_table(pointer_prev, offset, current_core_cycle[cpu]);

          // First look in prefetcher, since if there is a hit, it is the time the miss started
          // If no prefetch, then its latency is the demand one
      if (pref_latency == 0) {
        pref_latency = demand_latency;
      }

      if (demand_latency != 0) { // Not found, berti will not be found neither

            // Find berti (distance from pref_latency + demand_latency cycles before
        int berti[L2C_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS];
        l2c_get_berti_prev_requests_table(evicted_addr, 0, 0, 0,0,0,0,pointer_prev, offset, current_core_cycle[cpu] - (pref_latency + demand_latency), berti);
        for (int i = 0; i < L2C_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS; i++) {
          if (berti[i] == 0) break;
          assert(abs(berti[i]) < L2C_PAGE_BLOCKS);
          l2c_add_berti_current_pages_table(pointer_prev, berti[i]);
          }
        }
      }

    uint64_t victim_index = l2c_get_current_pages_entry(evicted_addr >> LOG2_PAGE_SIZE);
    if (victim_index < L2C_CURRENT_PAGES_TABLE_ENTRIES) {
          // Copy victim to record table
        l2c_record_current_page(victim_index);
        l2c_remove_current_table_entry(victim_index);
      }

    B_FILTER.check(evicted_addr,0,0,0,0,L2C_EVICT, 0,0,0,0);

    return metadata_in;
}
